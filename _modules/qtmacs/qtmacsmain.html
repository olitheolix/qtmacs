


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>qtmacs.qtmacsmain &mdash; Qtmacs 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../_static/cloud.js"></script>
    <link rel="top" title="Qtmacs 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <div class="relbar-top">
        
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">Qtmacs 0.1 documentation</a> &raquo;</li>

          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for qtmacs.qtmacsmain</h1><div class="highlight"><pre>
<span class="c"># Copyright 2012-2013, Oliver Nagy &lt;qtmacsdev@gmail.com&gt;</span>
<span class="c">#</span>
<span class="c"># This file is part of Qtmacs.</span>
<span class="c">#</span>
<span class="c"># Qtmacs is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># Qtmacs is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with Qtmacs. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is the central Qtmacs module.</span>

<span class="sd">It contains the following classes:</span>

<span class="sd">* ``QtmacsMain``: the engine behind Qtmacs. It defines *all* signals</span>
<span class="sd">  that Qtmacs (as an application) can emit, has no visible appearance,</span>
<span class="sd">  there can ever only be one instance of this class which must be</span>
<span class="sd">  created by hand.</span>
<span class="sd">* ``QtmacsWindow``: a window to display applets. There is always at</span>
<span class="sd">  least one instance. Do not instantiate this class manually.</span>
<span class="sd">* ``QtmacsEventFilter``: intercepts and filters all keyboard</span>
<span class="sd">  events. There is always only one instance of this class and it is</span>
<span class="sd">  (semi-)automatically installed on all widgets to ensure Qtmacs</span>
<span class="sd">  reacts to keyboard shortcuts. Do not instantiate this class</span>
<span class="sd">  manually.</span>
<span class="sd">* ``QtmacsSplitter``: used to visually split applets inside a</span>
<span class="sd">  ``QtmacsWindow``. The only difference with a normal ``QSplitter``</span>
<span class="sd">  are additional convenience methods and admin attributes for the</span>
<span class="sd">  Qtmacs layout engine.</span>
<span class="sd">* ``QtmacsPlaceholderApplet``: a virtual applet that is automatically</span>
<span class="sd">  inserted whenever no other applets are left to display in a window.</span>

<span class="sd">.. warning:: It is *not* safe to use ``from`` in order to import</span>
<span class="sd">   classes from this module.</span>

<span class="sd">Usage example (requires Python 3.x and PyQt 4.8)::</span>

<span class="sd">    import sys</span>
<span class="sd">    import qtmacs.qtmacsmain</span>
<span class="sd">    from PyQt4 import QtGui</span>

<span class="sd">    if __name__ == &#39;__main__&#39;:</span>
<span class="sd">        QtApplicationInstance = QtGui.QApplication(sys.argv)</span>
<span class="sd">        qtmacsMain = qtmacs.qtmacsmain.QtmacsMain()</span>
<span class="sd">        sys.exit(QtApplicationInstance.exec_())</span>

<span class="sd">.. note:: It is almost certainly a bad idea to use any of the classes</span>
<span class="sd">   in this module directly, except for a single instance of ``QtmacsMain``.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">imp</span>
<span class="kn">import</span> <span class="nn">sip</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">qtmacs.auxiliary</span>
<span class="kn">import</span> <span class="nn">qtmacs.kill_list</span>
<span class="kn">import</span> <span class="nn">qtmacs.type_check</span>
<span class="kn">import</span> <span class="nn">qtmacs.base_macro</span>
<span class="kn">import</span> <span class="nn">qtmacs.base_applet</span>
<span class="kn">import</span> <span class="nn">qtmacs.qtmacsmain_macros</span>
<span class="kn">import</span> <span class="nn">qtmacs.qte_global</span> <span class="kn">as</span> <span class="nn">qte_global</span>

<span class="kn">from</span> <span class="nn">PyQt4</span> <span class="kn">import</span> <span class="n">QtCore</span><span class="p">,</span> <span class="n">QtGui</span>
<span class="kn">from</span> <span class="nn">qtmacs.exceptions</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Shorthands.</span>
<span class="n">type_check</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">type_check</span><span class="o">.</span><span class="n">type_check</span>
<span class="n">QtmacsMacro</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">base_macro</span><span class="o">.</span><span class="n">QtmacsMacro</span>
<span class="n">QtmacsApplet</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">base_applet</span><span class="o">.</span><span class="n">QtmacsApplet</span>
<span class="n">QtmacsKeymap</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">auxiliary</span><span class="o">.</span><span class="n">QtmacsKeymap</span>
<span class="n">QtmacsMessage</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">auxiliary</span><span class="o">.</span><span class="n">QtmacsMessage</span>
<span class="n">QtmacsKeysequence</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">auxiliary</span><span class="o">.</span><span class="n">QtmacsKeysequence</span>
<span class="n">QtmacsAdminStructure</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">auxiliary</span><span class="o">.</span><span class="n">QtmacsAdminStructure</span>
<span class="n">qteIsQtmacsWidget</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">auxiliary</span><span class="o">.</span><span class="n">qteIsQtmacsWidget</span>
<span class="n">qteGetAppletFromWidget</span> <span class="o">=</span> <span class="n">qtmacs</span><span class="o">.</span><span class="n">auxiliary</span><span class="o">.</span><span class="n">qteGetAppletFromWidget</span>


<div class="viewcode-block" id="DeliverQtKeyEvent"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.DeliverQtKeyEvent">[docs]</a><span class="k">class</span> <span class="nc">DeliverQtKeyEvent</span><span class="p">(</span><span class="n">QtmacsMacro</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deliver a Qt key event to an unregistered Qt widget.</span>

<span class="sd">    This macro passes a ``QKeyEvent`` through to the Qt native</span>
<span class="sd">    ``keyPressed`` method. The purpose of this macro is to seamlessly</span>
<span class="sd">    integrate regular Qt widgets (ie. those not added with</span>
<span class="sd">    ``qteAddWidget``) into the macro framework, despite the fact that</span>
<span class="sd">    such widgets cannot have Qtmacs macros associated with it.</span>

<span class="sd">    The advantage of delivering key events via this macro is that</span>
<span class="sd">    such widgets are not served out of order and receive their</span>
<span class="sd">    respective key events only when all preceding keys (and their</span>
<span class="sd">    associated macros) were processed.</span>

<span class="sd">    ..note: this macro is the only \&quot;hard coded\&quot; macro in Qtmacs.</span>
<span class="sd">      It is registered in the constructor of ``QtmacsMain`` and</span>
<span class="sd">      explicitly used in the ``QtmacsEventFilter``.</span>

<span class="sd">    |Signature|</span>

<span class="sd">    * *applet*: &#39;*&#39;</span>
<span class="sd">    * *widget*: &#39;*&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteSetAppletSignature</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteSetWidgetSignature</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="DeliverQtKeyEvent.qteRun"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.DeliverQtKeyEvent.qteRun">[docs]</a>    <span class="k">def</span> <span class="nf">qteRun</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the last ``QKeyEvent`` from the keyboard sequence</span>
<span class="sd">        (there should only be one anyway, but just to be sure) and</span>
<span class="sd">        deliver it to the native ``keyPressEvent`` method of the</span>
<span class="sd">        widget. The actual call is wrapped in a try-except construct</span>
<span class="sd">        because the ``keyPressEvent`` are protected methods in the C++</span>
<span class="sd">        code and cannot be called from PyQt, unless the widget itself</span>
<span class="sd">        was created in PyQt as opposed to by Qt itself. A typical</span>
<span class="sd">        example are the automatic scrollbars of windows. If they have</span>
<span class="sd">        the focus (just click on them) when a keyboard event occurs</span>
<span class="sd">        then Python 3.2 throws the following exception: &quot;`RuntimeError:</span>
<span class="sd">        no access to protected functions or signals for objects not</span>
<span class="sd">        created from Python`&quot;.</span>

<span class="sd">        It remains to be seen if this poses a problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Ignore the request if the widget has no keyPressEvent method.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qteWidget</span><span class="p">,</span> <span class="s">&#39;keyPressEvent&#39;</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c"># Extract the last key and send it to the widget.</span>
        <span class="n">keyEvent</span> <span class="o">=</span> <span class="n">qte_global</span><span class="o">.</span><span class="n">last_key_sequence</span><span class="o">.</span><span class="n">toQKeyEventList</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteWidget</span><span class="o">.</span><span class="n">keyPressEvent</span><span class="p">(</span><span class="n">keyEvent</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="k">pass</span>

</div></div>
<div class="viewcode-block" id="QtmacsEventFilter"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsEventFilter">[docs]</a><span class="k">class</span> <span class="nc">QtmacsEventFilter</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intercept keystrokes, parse them, and queue the associated macros.</span>

<span class="sd">    This is the one and only event filter in Qtmacs. Every applet and</span>
<span class="sd">    registered widget (ie. widgets added with the ``qteAddWidget``) is</span>
<span class="sd">    under its control.</span>

<span class="sd">    This event handler is also the source for the ``qtesigAbort`` and</span>
<span class="sd">    ``qtesigKeyparsed`` signals that applets and macros can connect</span>
<span class="sd">    themselves to.</span>

<span class="sd">    |Args|</span>

<span class="sd">    * ``qteMain`` (**QtmacsMain**): reference to the one and only</span>
<span class="sd">      ``QtmacsMain`` instance.</span>

<span class="sd">    |Signals|</span>

<span class="sd">    * ``qtesigAbort``: the user pressed &lt;ctrl&gt;-g. The signal is emitted</span>
<span class="sd">      after Qtmacs&#39; internal cleanup actions, but (almost certainly)</span>
<span class="sd">      before GUI had a chance to update itself.</span>
<span class="sd">    * ``qtesigKeypressed``: a key was pressed. Connect to this signal if</span>
<span class="sd">      a global equivalent of the Qt native ``keypressed`` method is required.</span>

<span class="sd">      - ``targetObj`` (**QObject**): the original recipient of the signal.</span>
<span class="sd">      - ``keyEvent`` (**QKeyEvent**): last pressed key.</span>

<span class="sd">    * ``qtesigKeyparsed`` (targetObj, keysequence, macroName): Qtmacs</span>
<span class="sd">      has finished parsing the key sequence. This signal is similar to</span>
<span class="sd">      ``qtesigKeypressed`` but is never triggered for pure modifier</span>
<span class="sd">      combinations (eg. just pressing &lt;ctrl&gt; will not trigger it).</span>

<span class="sd">      - ``targetObj`` (**QObject**): the original recipient of the signal.</span>
<span class="sd">      - ``keysequence`` (**QtmacsKeysequence**): key sequence since it</span>
<span class="sd">        was last reset (ie. was either invalid or specified a macro).</span>
<span class="sd">      - ``macroName`` (**str**): either the name of the macro associated</span>
<span class="sd">        with the just completed</span>
<span class="sd">        ``keysequence``, or **None** if still incomplete.</span>

<span class="sd">    * qtesigKeyseqComplete: the last key completed a valid</span>
<span class="sd">      shortcut sequence for a macro.</span>

<span class="sd">      - ``macroName`` (**str**): name of macro associated with</span>
<span class="sd">        ``keysequence``.</span>
<span class="sd">      - ``keysequence`` (**QtmacsKeysequence**): the actual key</span>
<span class="sd">        sequence.</span>

<span class="sd">    * qtesigKeyseqPartial: the last key did not complete a</span>
<span class="sd">      macro shortcut.</span>

<span class="sd">      - ``keysequence`` (**QtmacsKeysequence**): the actual key</span>
<span class="sd">        sequence.</span>

<span class="sd">    * qtesigKeyseqInvalid: the last key rendered the key sequence</span>
<span class="sd">      invalid, ie. it cannot possibly lead to valid macro shortcut</span>
<span class="sd">      anymore.</span>

<span class="sd">      - ``keysequence`` (**QtmacsKeysequence**): the actual key</span>
<span class="sd">        sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c"># The keysequence typed by the user until it either</span>
        <span class="c"># points to a macro becomes invalid.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keysequence</span> <span class="o">=</span> <span class="n">QtmacsKeysequence</span><span class="p">()</span>

        <span class="c"># Flag to turn off macro processing (automatically reset</span>
        <span class="c"># when the user presses &lt;ctrl&gt;+g).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteFlagRunMacro</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Shorhands:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span> <span class="o">=</span> <span class="n">qte_global</span><span class="o">.</span><span class="n">qteMain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qApp</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>

        <span class="c"># List of events intercepted by this handler.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteEventList</span> <span class="o">=</span> <span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QEvent</span><span class="o">.</span><span class="n">KeyPress</span><span class="p">,</span>
                             <span class="n">QtCore</span><span class="o">.</span><span class="n">QEvent</span><span class="o">.</span><span class="n">MouseButtonPress</span><span class="p">)</span>

        <span class="c"># The name of the macro that will deliver key events</span>
        <span class="c"># to widgets not registered with Qtmacs, yet are part of</span>
        <span class="c"># its widget hierarchy.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">QtDelivery</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qteMacroNameMangling</span><span class="p">(</span><span class="n">DeliverQtKeyEvent</span><span class="p">)</span>

<div class="viewcode-block" id="QtmacsEventFilter.eventFilter"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsEventFilter.eventFilter">[docs]</a>    <span class="k">def</span> <span class="nf">eventFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetObj</span><span class="p">,</span> <span class="n">event_qt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intercept keyboard events and pass them on to the key parser</span>
<span class="sd">        and/or applet and/or widget.</span>

<span class="sd">        The handler only intercepts keyboard events and lets Qt handle</span>
<span class="sd">        the remaining ones (eg. mouse clicks) as usual.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``targetObj`` (**QObject**): the source of the event (see Qt</span>
<span class="sd">          documentation).</span>
<span class="sd">        * ``event_qt`` (**QEvent**): information about the event (see Qt</span>
<span class="sd">          documentation).</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: if **True**, Qt will consider the event handled.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Return immediately if Qtmacs is not interested in it.</span>
        <span class="k">if</span> <span class="n">event_qt</span><span class="o">.</span><span class="n">type</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteEventList</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Determine if the widget belongs to the Qtmacs hierarchy and</span>
        <span class="c"># return immediately if not.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">qteIsQtmacsWidget</span><span class="p">(</span><span class="n">targetObj</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># If the event is a mouse click then update the Qtmacs internal</span>
        <span class="c"># focus state and tell the Qt library that the event was NOT</span>
        <span class="c"># handled. This ensures the click is propagated to the widget.</span>
        <span class="k">if</span> <span class="n">event_qt</span><span class="o">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QEvent</span><span class="o">.</span><span class="n">MouseButtonPress</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">_qteMouseClicked</span><span class="p">(</span><span class="n">targetObj</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Make a copy of the QKeyEvent because Qt will delete the</span>
        <span class="c"># underlying object as soon as the event is handled. However, some</span>
        <span class="c"># macros might retain a reference which will then become invalid</span>
        <span class="c"># and result in a difficult to trace bug. Therefore, supply them</span>
        <span class="c"># with an explicit copy only.</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QKeyEvent</span><span class="p">(</span><span class="n">event_qt</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">event_qt</span><span class="o">.</span><span class="n">key</span><span class="p">(),</span>
                                <span class="n">event_qt</span><span class="o">.</span><span class="n">modifiers</span><span class="p">(),</span> <span class="n">event_qt</span><span class="o">.</span><span class="n">text</span><span class="p">(),</span>
                                <span class="n">event_qt</span><span class="o">.</span><span class="n">isAutoRepeat</span><span class="p">(),</span> <span class="n">event_qt</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>

        <span class="c"># Abort the input if the user presses &lt;ctrl&gt;-g and declare the</span>
        <span class="c"># keyboard event handled.</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">modifiers</span><span class="p">()</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">==</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">ControlModifier</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Key_G</span><span class="p">):</span>
            <span class="c"># Furthermore, clear the key sequence and ensure macro execution</span>
            <span class="c"># is turned on again.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keysequence</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteFlagRunMacro</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c"># Remove the mini applet.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qteKillMiniApplet</span><span class="p">()</span>

            <span class="c"># Drop all macros and keys left in the respective queues.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">_qteMacroQueue</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">_qteKeyEmulationQueue</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c"># Ensure the focus manager runs once the event loop is idle again.</span>
            <span class="c"># Also, emit the abort signal.</span>
            <span class="n">msgObj</span> <span class="o">=</span> <span class="n">QtmacsMessage</span><span class="p">()</span>
            <span class="n">msgObj</span><span class="o">.</span><span class="n">setSignalName</span><span class="p">(</span><span class="s">&#39;qtesigAbort&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qtesigAbort</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">msgObj</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># If the widget is unregistered then parse the key without further</span>
        <span class="c"># ado and declare the key event handled via the return value.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">targetObj</span><span class="p">,</span> <span class="s">&#39;_qteAdmin&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteProcessKey</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">targetObj</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># Shorthand to the QtmacsApplet that received this event.</span>
        <span class="n">qteApplet</span> <span class="o">=</span> <span class="n">targetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">qteApplet</span>

        <span class="c"># Retrieve information about how the widget wants its keyboard</span>
        <span class="c"># events processed.</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">targetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyFilterPolicy</span><span class="p">()</span>
        <span class="n">receiveBefore</span><span class="p">,</span> <span class="n">useQtmacs</span><span class="p">,</span> <span class="n">receiveAfter</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">del</span> <span class="n">tmp</span>

        <span class="c"># If the applet requested the keyboard input before being</span>
        <span class="c"># processed by Qtmacs then send the event to the applet which</span>
        <span class="c"># harbours the object (ie. *NOT* the object itself). It is the</span>
        <span class="c"># responsibility of the applet to enact the desired</span>
        <span class="c"># behaviour. If this action is the native behaviour of the</span>
        <span class="c"># widget then the applet should consider using</span>
        <span class="c"># &quot;self.qteText.keyPressEvent(keyEvent)&quot; to achieve this.</span>
        <span class="k">if</span> <span class="n">receiveBefore</span><span class="p">:</span>
            <span class="n">qteApplet</span><span class="o">.</span><span class="n">qteKeyPressEventBefore</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">targetObj</span><span class="p">)</span>

        <span class="c"># If the applet wants Qtmacs to process the keyboard event then do so.</span>
        <span class="k">if</span> <span class="n">useQtmacs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteProcessKey</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">targetObj</span><span class="p">)</span>

        <span class="c"># If the applet requested the keyboard input after being</span>
        <span class="c"># processed by Qtmacs then send the event to the applet which</span>
        <span class="c"># harbours the object (ie. *NOT* the object itself). It is the</span>
        <span class="c"># responsibility of the applet to enact the desired behaviour</span>
        <span class="c"># on the object.</span>
        <span class="k">if</span> <span class="n">receiveAfter</span><span class="p">:</span>
            <span class="n">qteApplet</span><span class="o">.</span><span class="n">qteKeyPressEventAfter</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">targetObj</span><span class="p">)</span>

        <span class="c"># Declare the key event handled.</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="QtmacsEventFilter.qteProcessKey"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsEventFilter.qteProcessKey">[docs]</a>    <span class="k">def</span> <span class="nf">qteProcessKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">targetObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the key completes a valid key sequence then queue the</span>
<span class="sd">        associated macro.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``targetObj`` (**QObject**): the source of the event</span>
<span class="sd">          (see Qt documentation).</span>
<span class="sd">        * ``event_qt`` (**QKeyEvent**): information about the key</span>
<span class="sd">          event (see Qt documentation).</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **Bool**: **True** if there was at least a partial match and</span>
<span class="sd">                    **False** if the key sequence was invalid.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Announce the key and targeted Qtmacs widget.</span>
        <span class="n">msgObj</span> <span class="o">=</span> <span class="n">QtmacsMessage</span><span class="p">((</span><span class="n">targetObj</span><span class="p">,</span> <span class="n">event</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">msgObj</span><span class="o">.</span><span class="n">setSignalName</span><span class="p">(</span><span class="s">&#39;qtesigKeypressed&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qtesigKeypressed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">msgObj</span><span class="p">)</span>

        <span class="c"># Ignore standalone &lt;Shift&gt;, &lt;Ctrl&gt;, &lt;Win&gt;, &lt;Alt&gt;, and &lt;AltGr&gt;</span>
        <span class="c"># events.</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Key_Shift</span><span class="p">,</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Key_Control</span><span class="p">,</span>
                           <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Key_Meta</span><span class="p">,</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Key_Alt</span><span class="p">,</span>
                           <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Key_AltGr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Add the latest key stroke to the current key sequence.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keysequence</span><span class="o">.</span><span class="n">appendQKeyEvent</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

        <span class="c"># Determine if the widget was registered with qteAddWidget</span>
        <span class="n">isRegisteredWidget</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">targetObj</span><span class="p">,</span> <span class="s">&#39;_qteAdmin&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isRegisteredWidget</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">targetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="p">,</span> <span class="s">&#39;keyMap&#39;</span><span class="p">):</span>
            <span class="n">keyMap</span> <span class="o">=</span> <span class="n">targetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyMap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">_qteGlobalKeyMapByReference</span><span class="p">()</span>

        <span class="c"># See if there is a match with an entry from the key map of</span>
        <span class="c"># the current object. If ``isPartialMatch`` is True then the</span>
        <span class="c"># key sequence is potentially incomplete, but not invalid.</span>
        <span class="c"># If ``macroName`` is not **None** then it is indeed complete.</span>
        <span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">isPartialMatch</span><span class="p">)</span> <span class="o">=</span> <span class="n">keyMap</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keysequence</span><span class="p">)</span>

        <span class="c"># Make a convenience copy of the key sequence.</span>
        <span class="n">keyseq_copy</span> <span class="o">=</span> <span class="n">QtmacsKeysequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keysequence</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isPartialMatch</span><span class="p">:</span>
            <span class="c"># Reset the key combination history if a valid macro was</span>
            <span class="c"># found so that the next key that arrives starts a new key</span>
            <span class="c"># sequence.</span>
            <span class="k">if</span> <span class="n">macroName</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># Report a partially completed key-sequence.</span>
                <span class="n">msgObj</span> <span class="o">=</span> <span class="n">QtmacsMessage</span><span class="p">(</span><span class="n">keyseq_copy</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">msgObj</span><span class="o">.</span><span class="n">setSignalName</span><span class="p">(</span><span class="s">&#39;qtesigKeyseqPartial&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qtesigKeyseqPartial</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">msgObj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Execute the macro if requested.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteFlagRunMacro</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qteRunMacro</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">targetObj</span><span class="p">,</span> <span class="n">keyseq_copy</span><span class="p">)</span>

                <span class="c"># Announce that the key sequence lead to a valid macro.</span>
                <span class="n">msgObj</span> <span class="o">=</span> <span class="n">QtmacsMessage</span><span class="p">((</span><span class="n">macroName</span><span class="p">,</span> <span class="n">keyseq_copy</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">msgObj</span><span class="o">.</span><span class="n">setSignalName</span><span class="p">(</span><span class="s">&#39;qtesigKeyseqComplete&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qtesigKeyseqComplete</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">msgObj</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_keysequence</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isRegisteredWidget</span><span class="p">:</span>
                <span class="c"># Announce (and log) that the key sequence is invalid. However,</span>
                <span class="c"># format the key string to Html first, eg. &quot;&lt;ctrl&gt;-x i&quot; to</span>
                <span class="c"># &quot;&lt;b&gt;&amp;lt;Ctrl&amp;gt;+x i&lt;/b&gt;&quot;.</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">keyseq_copy</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s">&#39;&amp;lt;&#39;</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;&amp;gt;&#39;</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;No macro is bound to &lt;b&gt;{}&lt;/b&gt;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">msgObj</span> <span class="o">=</span> <span class="n">QtmacsMessage</span><span class="p">(</span><span class="n">keyseq_copy</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">msgObj</span><span class="o">.</span><span class="n">setSignalName</span><span class="p">(</span><span class="s">&#39;qtesigKeyseqInvalid&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qtesigKeyseqInvalid</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">msgObj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># If we are in this branch then the widet is part of the</span>
                <span class="c"># Qtmacs widget hierachy yet was not registered with</span>
                <span class="c"># the qteAddWidget method. In this case use the QtDelivery</span>
                <span class="c"># macro to pass on whatever the event was (assuming</span>
                <span class="c"># macro processing is enabled).</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteFlagRunMacro</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qteRunMacro</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">QtDelivery</span><span class="p">,</span> <span class="n">targetObj</span><span class="p">,</span> <span class="n">keyseq_copy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keysequence</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c"># Announce that Qtmacs has processed another key event. The</span>
        <span class="c"># outcome of this processing is communicated along with the</span>
        <span class="c"># signal.</span>
        <span class="n">msgObj</span> <span class="o">=</span> <span class="n">QtmacsMessage</span><span class="p">((</span><span class="n">targetObj</span><span class="p">,</span> <span class="n">keyseq_copy</span><span class="p">,</span> <span class="n">macroName</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">msgObj</span><span class="o">.</span><span class="n">setSignalName</span><span class="p">(</span><span class="s">&#39;qtesigKeyparsed&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span><span class="o">.</span><span class="n">qtesigKeyparsed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">msgObj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">isPartialMatch</span>
</div>
<div class="viewcode-block" id="QtmacsEventFilter.qteEnableMacroProcessing"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsEventFilter.qteEnableMacroProcessing">[docs]</a>    <span class="k">def</span> <span class="nf">qteEnableMacroProcessing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute macro whenever a valid key sequence was entered.</span>

<span class="sd">        This method clears any partially entered key sequence.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteFlagRunMacro</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keysequence</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="QtmacsEventFilter.qteDisableMacroProcessing"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsEventFilter.qteDisableMacroProcessing">[docs]</a>    <span class="k">def</span> <span class="nf">qteDisableMacroProcessing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not execute any macros upon typing a valid key sequence.</span>

<span class="sd">        This method only prevents the event handler from queuing any</span>
<span class="sd">        macro for execution, but other than that it operates as</span>
<span class="sd">        usual. In particular, it keeps filtering the keys, matching</span>
<span class="sd">        them against pre-defined keyboard sequence, and emit all its</span>
<span class="sd">        signals, eg. ``abort``.</span>

<span class="sd">        This method does not reset itself unless either</span>
<span class="sd">        ``qteEnableMacroProcessing`` is called or the user enters</span>
<span class="sd">        &lt;ctrl&gt;+g.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteFlagRunMacro</span> <span class="o">=</span> <span class="bp">False</span>

</div></div>
<div class="viewcode-block" id="QtmacsSplitter"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsSplitter">[docs]</a><span class="k">class</span> <span class="nc">QtmacsSplitter</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QSplitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A normal ``QSplitter`` but with an _qteAdmin structure to disguise</span>
<span class="sd">    it as a ``Qtmacs`` widget.</span>

<span class="sd">    The disguise is necessary because these splitters are the parent</span>
<span class="sd">    of every visible applet, and some methods query information about</span>
<span class="sd">    its parent assuming that it is another widget under the control of</span>
<span class="sd">    Qtmacs.</span>

<span class="sd">    |Args|</span>

<span class="sd">    * ``orient`` (**Qt.Orientation**): orientation of the splitter</span>
<span class="sd">      (ie. horizontal or vertical)</span>
<span class="sd">    * ``parent_win`` (**QtmacsApplet**): the window in which the</span>
<span class="sd">      splitter exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="p">,</span> <span class="n">parent_win</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">orient</span><span class="p">)</span>

        <span class="c"># Destroy the splitter when its close() method is called.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">WA_DeleteOnClose</span><span class="p">)</span>

        <span class="c"># Add a _qteAdmin structure to the splitter and give it a hard</span>
        <span class="c"># coded signature.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAdmin</span> <span class="o">=</span> <span class="n">QtmacsAdminStructure</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span> <span class="o">=</span> <span class="s">&#39;__QtmacsLayoutSplitter__&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">parentWindow</span> <span class="o">=</span> <span class="n">parent_win</span>

<div class="viewcode-block" id="QtmacsSplitter.qteAddWidget"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsSplitter.qteAddWidget">[docs]</a>    <span class="k">def</span> <span class="nf">qteAddWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widget</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a widget to the splitter and make it visible.</span>

<span class="sd">        The only two differences between this method and the native</span>
<span class="sd">        ``QSplitter.insertWidget()`` method is that this one 1)</span>
<span class="sd">        expects the widget to have a ``QtmacsAdmin`` structure (ie. to</span>
<span class="sd">        be a ``QtmacsApplet`` or a ``QtmacsSplitter``) and 2) make the</span>
<span class="sd">        widget visible automatically. Both is mostly for convenience</span>
<span class="sd">        because adding a widget to the splitter in Qtmacs is</span>
<span class="sd">        tantamount to displaying it.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``widget`` (**QWidget**): the widget to add to the splitter.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">QtGui</span><span class="o">.</span><span class="n">QSplitter</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widget</span><span class="p">)</span>

        <span class="c"># If the widget is QtmacsSplitter then its show() methods has</span>
        <span class="c"># no argument, whereas any applet has an overloaded show()</span>
        <span class="c"># function.</span>
        <span class="k">if</span> <span class="n">widget</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span> <span class="o">==</span> <span class="s">&#39;__QtmacsLayoutSplitter__&#39;</span><span class="p">:</span>
            <span class="n">widget</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">widget</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="QtmacsSplitter.qteInsertWidget"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsSplitter.qteInsertWidget">[docs]</a>    <span class="k">def</span> <span class="nf">qteInsertWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">widget</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert ``widget`` to the splitter at the specified ``idx``</span>
<span class="sd">        position and make it visible.</span>

<span class="sd">        The only two differences between this method and the native</span>
<span class="sd">        ``QSplitter.insertWidget()`` method is that this one</span>

<span class="sd">        1. expects the widget to have a ``QtmacsAdmin`` structure</span>
<span class="sd">           (ie. to be a ``QtmacsApplet`` or a ``QtmacsSplitter``)</span>
<span class="sd">        2. make the widget visible automatically.</span>

<span class="sd">        Both are mostly for convenience because adding a ``widget`` to</span>
<span class="sd">        the splitter in Qtmacs is tantamount to displaying it.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``idx`` (**int**): non-negative index position.</span>
<span class="sd">        * ``widget`` (**QWidget**): the widget to insert into the</span>
<span class="sd">          splitter at position ``idx``.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">QtGui</span><span class="o">.</span><span class="n">QSplitter</span><span class="o">.</span><span class="n">insertWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">widget</span><span class="p">)</span>

        <span class="c"># If the widget is QtmacsSplitter then its show() methods has</span>
        <span class="c"># no argument, whereas any applet has an overloaded show()</span>
        <span class="c"># function.</span>
        <span class="k">if</span> <span class="n">widget</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span> <span class="o">==</span> <span class="s">&#39;__QtmacsLayoutSplitter__&#39;</span><span class="p">:</span>
            <span class="n">widget</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">widget</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="QtmacsSplitter.qteParentWindow"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsSplitter.qteParentWindow">[docs]</a>    <span class="k">def</span> <span class="nf">qteParentWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a reference to the parent window.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsWindow**: reference to window object that harbours</span>
<span class="sd">          this splitter.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">parentWindow</span>

</div></div>
<div class="viewcode-block" id="QtmacsWindow"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsWindow">[docs]</a><span class="k">class</span> <span class="nc">QtmacsWindow</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A window that can display Qtmacs applets.</span>

<span class="sd">    Upon creation this window is empty.</span>

<span class="sd">    |Args|</span>

<span class="sd">    * ``windowPos`` (**QRect**): position and size of window</span>
<span class="sd">      on screen.</span>
<span class="sd">    * ``windowID`` (**str**): unique window ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windowPos</span><span class="p">,</span> <span class="n">windowID</span><span class="p">):</span>
        <span class="c"># Call the base class constructors.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c"># Keep a handle to the QtmacsMain instance.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteMain</span> <span class="o">=</span> <span class="n">qte_global</span><span class="o">.</span><span class="n">qteMain</span>

        <span class="c"># Insert the admin structure and populate it with hard coded values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAdmin</span> <span class="o">=</span> <span class="n">QtmacsAdminStructure</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">isQtmacsWindow</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">appletID</span> <span class="o">=</span> <span class="s">&#39;__QtmacsMain__&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">appletSignature</span> <span class="o">=</span> <span class="s">&#39;__QtmacsMain__&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span> <span class="o">=</span> <span class="s">&#39;__QtmacsMain__&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowID</span> <span class="o">=</span> <span class="n">windowID</span>

        <span class="c"># Set the window title and icon.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s">&#39;Qtmacs Window: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowID</span><span class="p">))</span>

        <span class="c"># Locate the Qtmacs logo and install it as the application icon.</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">qtmacs</span><span class="o">.</span><span class="n">qtmacsmain</span><span class="o">.</span><span class="n">__file__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowIcon</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QIcon</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s">&#39;/misc/Max.png&#39;</span><span class="p">))</span>

        <span class="c"># Specify the initial size of the main applet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setGeometry</span><span class="p">(</span><span class="n">windowPos</span><span class="p">)</span>

        <span class="c"># Instantiate the status applet.</span>
        <span class="kn">import</span> <span class="nn">qtmacs.applets.statusbar</span> <span class="kn">as</span> <span class="nn">statusbar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteStatusBar</span> <span class="o">=</span> <span class="n">statusbar</span><span class="o">.</span><span class="n">StatusBar</span><span class="p">(</span><span class="s">&#39;**Status**&#39;</span><span class="p">)</span>

        <span class="c"># Create two splitters. The ``qteAppletSplitter`` always</span>
        <span class="c"># contains the normal applets and is capable of tiling them</span>
        <span class="c"># (if necessary, by adding more sub-splitters), whereas</span>
        <span class="c"># ``qteLayoutSplitter`` separates the applet splitter and the</span>
        <span class="c"># mini/status applet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteAppletSplitter</span> <span class="o">=</span> <span class="n">QtmacsSplitter</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Horizontal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLayoutSplitter</span> <span class="o">=</span> <span class="n">QtmacsSplitter</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Vertical</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLayoutSplitter</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLayoutSplitter</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qteStatusBar</span><span class="p">)</span>

        <span class="c"># Install the just created layout as the window layout.</span>
        <span class="n">hbox</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QHBoxLayout</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">hbox</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qteLayoutSplitter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">hbox</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="QtmacsMain"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain">[docs]</a><span class="k">class</span> <span class="nc">QtmacsMain</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class administrates Qtmacs and has exactly **one** instance.</span>

<span class="sd">    ``QtmacsMain`` itself has no visible appearance but spawns a</span>
<span class="sd">    ``QmacsWindow`` upon instantiation which it populates with the</span>
<span class="sd">    ``LogViewer`` applet to log messages. It then sets up a logger</span>
<span class="sd">    object (from the standard ``logging`` module) to facilitate a</span>
<span class="sd">    unified logging interface, defines the signals that Qtmacs emits</span>
<span class="sd">    (not necessarily from this class).</span>

<span class="sd">    This class also defines *all* Qtmacs wide signals despite emitting</span>
<span class="sd">    hardly any of them itself (most are issued by applet- and macro</span>
<span class="sd">    classes). The reason for defining them here nonetheless is to make</span>
<span class="sd">    it easier on the applet/macro programmer and put them all into a</span>
<span class="sd">    single place where they can be reached via ``self.qteMain``</span>
<span class="sd">    (eg. ``qtesigAbort.connect(myAbortMethod)``).</span>

<span class="sd">    .. note:: Qtmacs is a ~3000 lines long state machine as well as a</span>
<span class="sd">              plugin system on steroids that uses its own Python</span>
<span class="sd">              instance to run third party Python code over which it</span>
<span class="sd">              has no control. To shield it from as many unintended</span>
<span class="sd">              errors and inconsistencies as practically possible its</span>
<span class="sd">              methods enforce strict (and unpythonic) annotation based</span>
<span class="sd">              type checks on all its input arguments. These checks</span>
<span class="sd">              alleviate the risk of inconsistent arguments going</span>
<span class="sd">              unnoticed until either an unrelated applet or macro uses</span>
<span class="sd">              it (almost impossible to trace, but not probably</span>
<span class="sd">              uncritical), or Qtmacs itself uses it (also almost</span>
<span class="sd">              impossible to trace, but possibly fatal). For the same</span>
<span class="sd">              reason, the methods are simple, task oriented, and do</span>
<span class="sd">              not try to be smart. It is the responsibility of the</span>
<span class="sd">              applet/macro programmer to combine these methods to</span>
<span class="sd">              implement a more complex behaviour.</span>

<span class="sd">    |Args|</span>

<span class="sd">    * ``parent`` (**QWidget**): **None** if Qtmacs runs standalone,</span>
<span class="sd">        otherwise the parent widget.</span>
<span class="sd">    * ``importFile`` (**str**): name of module to import at startup.</span>
<span class="sd">    * ``logConsole`` (**bool**): if **True**, write all log messages</span>
<span class="sd">        to the console and log viewer applet.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Define the signals Qtmacs can emit.</span>
    <span class="n">qtesigAbort</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigCloseQtmacs</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigMacroStart</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigMacroFinished</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigMacroError</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigKeypressed</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigKeyparsed</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigKeyseqPartial</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigKeyseqComplete</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>
    <span class="n">qtesigKeyseqInvalid</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtSignal</span><span class="p">(</span><span class="n">QtmacsMessage</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">importFile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">logConsole</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c"># Call the base class constructors.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="c"># Copy a reference of this instance into the qte_global</span>
        <span class="c"># module. Note that this is the first- and last time this</span>
        <span class="c"># variable is set for the entire life of this Qtmacs instance!</span>
        <span class="n">qte_global</span><span class="o">.</span><span class="n">qteMain</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Define all lists, queues, timers, and admin variables.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMacroQueue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryHooks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryApplets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteKeyEmulationQueue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteGlobalKeyMap</span> <span class="o">=</span> <span class="n">QtmacsKeymap</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Timer ID to trigger the focus manager. At startup,</span>
        <span class="c"># invoke it as soon as this class was fully initialised.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteTimerFocusManager</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Timer ID to execute a queued macro.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteTimerRunMacro</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Setup the logging facility for Qtmacs. This consists of</span>
        <span class="c"># a ``logging.getLogger`` instance that can henceforth be</span>
        <span class="c"># used throughout all of Qtmacs. A reference is copied to</span>
        <span class="c"># ``qte_global`` but all applets and macros automatically</span>
        <span class="c"># have access to it via their ``self.qteLogger`` attribute.</span>
        <span class="c"># ------------------------------------------------------------</span>

        <span class="c"># Create the logger instance.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;qtmacs&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteDefVar</span><span class="p">(</span><span class="s">&#39;qteLogger&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="p">,</span>
                       <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Instance of ``logging.getLogger(&#39;qtmacs&#39;)``.&quot;</span><span class="p">)</span>

        <span class="c"># Add a stream handler if requested. This handler dumps all</span>
        <span class="c"># log messages to the console but has no effect on the log</span>
        <span class="c"># viewer applet in Qtmacs. The main purpose of this additional</span>
        <span class="c"># handler is to track error messages that occur before the</span>
        <span class="c"># logging applet is started (cannot be done this early), or</span>
        <span class="c"># when Qtmacs fails start up at all (eg. error in this very</span>
        <span class="c"># constructor).</span>
        <span class="k">if</span> <span class="n">logConsole</span><span class="p">:</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%(levelname)s</span><span class="s"> - </span><span class="si">%(message)s</span><span class="s">&#39;</span><span class="p">)</span>
            <span class="n">streamHandler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
            <span class="n">streamHandler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
            <span class="n">streamHandler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">streamHandler</span><span class="p">)</span>

        <span class="c"># Re-route the except hook to a custom object to capture all</span>
        <span class="c"># errors not otherwise captured, and feed them into the</span>
        <span class="c"># Qtmacs logger.</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">excepthook</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">QtmacsExceptHook</span>

        <span class="c"># Perform OS- and machine specific setup.</span>
        <span class="kn">import</span> <span class="nn">qtmacs.platform_setup</span>
        <span class="n">qtmacs</span><span class="o">.</span><span class="n">platform_setup</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Instantiate the (one and only) event filter for Qtmacs,</span>
        <span class="c"># load the global macros and keybindings (eg. for switching</span>
        <span class="c"># applets, executing macros, quitting Qtmacs, etc.), and</span>
        <span class="c"># manually create the first Qtmacs window.</span>
        <span class="c"># ------------------------------------------------------------</span>

        <span class="c"># Register the macro that delivers Qt key events to widgets</span>
        <span class="c"># that are part of the Qtmacs widget hierarchy, but were</span>
        <span class="c"># not officially registered with Qtmacs. Since the keyboard</span>
        <span class="c"># events for these widgets are nonetheless intercepted by</span>
        <span class="c"># the Qtmacs event handler they are delivered with the</span>
        <span class="c"># special macro ``DelierQtKeyEvent``.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteRegisterMacro</span><span class="p">(</span><span class="n">DeliverQtKeyEvent</span><span class="p">)</span>

        <span class="c"># Instantiate the keyboard filter for Qtmacs. This must</span>
        <span class="c"># happen after the call to qtmacs.platform_setup (see</span>
        <span class="c"># line above) since it relies on the variables</span>
        <span class="c"># &quot;Qt_key_map&quot; and &quot;Qt_modifier_map&quot;.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteEventFilter</span> <span class="o">=</span> <span class="n">QtmacsEventFilter</span><span class="p">()</span>

        <span class="c"># Import the applet- and widget independent macros and</span>
        <span class="c"># key-bindings to provide the core functionality for Qtmacs.</span>
        <span class="n">qtmacs</span><span class="o">.</span><span class="n">qtmacsmain_macros</span><span class="o">.</span><span class="n">install_macros_and_bindings</span><span class="p">()</span>

        <span class="c"># Instantiate the first window.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteNewWindow</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QRect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">750</span><span class="p">,</span> <span class="mi">500</span><span class="p">))</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Create an instance of the ``QtmacsKillList`` and add it to</span>
        <span class="c"># qte_global to make the same instance available to every</span>
        <span class="c"># applet that wants to use it.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="kn">import</span> <span class="nn">qtmacs.kill_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteDefVar</span><span class="p">(</span><span class="s">&#39;kill_list&#39;</span><span class="p">,</span>
                       <span class="n">qtmacs</span><span class="o">.</span><span class="n">kill_list</span><span class="o">.</span><span class="n">QtmacsKillList</span><span class="p">(),</span>
                       <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Instance of ``QtmacsKillList`` class.&quot;</span><span class="p">)</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Register and instantiate the ``logviewer`` applet. It will</span>
        <span class="c"># automatically connect to the Qtmacs wide logger instance to</span>
        <span class="c"># intercept all log messages.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="kn">import</span> <span class="nn">qtmacs.applets.logviewer</span> <span class="kn">as</span> <span class="nn">logviewer</span>
        <span class="n">appName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteRegisterApplet</span><span class="p">(</span><span class="n">logviewer</span><span class="o">.</span><span class="n">LogViewer</span><span class="p">)</span>
        <span class="n">appObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNewApplet</span><span class="p">(</span><span class="n">appName</span><span class="p">,</span> <span class="s">&#39;**LogViewer**&#39;</span><span class="p">)</span>

        <span class="c"># Error checking.</span>
        <span class="k">if</span> <span class="n">appObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Fatal error: could not instantiate the log viewer applet.&#39;</span>
            <span class="k">raise</span> <span class="n">QtmacsOtherError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteMakeAppletActive</span><span class="p">(</span><span class="n">appObj</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">logviewer</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Pick up mouse clicks to synchronise the Qtmacs internal</span>
        <span class="c"># state variables.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="n">qApp</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>
        <span class="n">qApp</span><span class="o">.</span><span class="n">installEventFilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteEventFilter</span><span class="p">)</span>

        <span class="n">qApp</span><span class="o">.</span><span class="n">focusChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qteFocusChanged</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">qApp</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Load the global configuration file.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Determine the path of this very file and add it to the</span>
        <span class="c"># Python load path. Then load the global configuration file</span>
        <span class="c"># which is in the same path.</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">qtmacs</span><span class="o">.</span><span class="n">qtmacsmain</span><span class="o">.</span><span class="n">__file__</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Loading global configuration file.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteImportModule</span><span class="p">(</span><span class="s">&#39;config.py&#39;</span><span class="p">)</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># So far, so good.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Initialisation of Qtmacs complete.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">importFile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Loading file &lt;b&gt;{}&lt;/b&gt;.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">importFile</span><span class="p">))</span>
            <span class="c"># Load the user specific configuration file.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteImportModule</span><span class="p">(</span><span class="n">importFile</span><span class="p">)</span>

        <span class="c"># Trigger the focus manager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteUpdate</span><span class="p">()</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Testing and debugging from here on.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="c">#self.debugTimer = self.startTimer(2000)</span>

<div class="viewcode-block" id="QtmacsMain.timerEvent"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.timerEvent">[docs]</a>    <span class="k">def</span> <span class="nf">timerEvent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trigger the focus manager and work off all queued macros.</span>

<span class="sd">        The main purpose of using this timer event is to postpone</span>
<span class="sd">        updating the visual layout of Qtmacs until all macro code has</span>
<span class="sd">        been fully executed. Furthermore, this GUI update needs to</span>
<span class="sd">        happen in between any two macros.</span>

<span class="sd">        This method will trigger itself until all macros in the queue</span>
<span class="sd">        were executed.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``event`` (**QTimerEvent**): Qt native event description.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">killTimer</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">timerId</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">timerId</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteTimerRunMacro</span><span class="p">:</span>
            <span class="c"># Declare the macro execution timer event handled.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteTimerRunMacro</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># If we are in this branch then the focus manager was just</span>
            <span class="c"># executed, the event loop has updated all widgets and</span>
            <span class="c"># cleared out all signals, and there is at least one macro</span>
            <span class="c"># in the macro queue and/or at least one key to emulate</span>
            <span class="c"># in the key queue. Execute the macros/keys and trigger</span>
            <span class="c"># the focus manager after each. The macro queue is cleared</span>
            <span class="c"># out first and the keys are only emulated if no more</span>
            <span class="c"># macros are left.</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMacroQueue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">qteWidget</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMacroQueue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_qteRunQueuedMacro</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">qteWidget</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteKeyEmulationQueue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># Determine the recipient of the event. This can</span>
                    <span class="c"># be, in order of preference, the active widget in</span>
                    <span class="c"># the active applet, or just the active applet (if</span>
                    <span class="c"># it has no widget inside), or the active window</span>
                    <span class="c"># (if no applets are available).</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">receiver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteActiveWindow</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span><span class="o">.</span><span class="n">_qteActiveWidget</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">receiver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">receiver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span><span class="o">.</span><span class="n">_qteActiveWidget</span>

                    <span class="c"># Call the event filter directly and trigger the focus</span>
                    <span class="c"># manager again.</span>
                    <span class="n">keysequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteKeyEmulationQueue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_qteEventFilter</span><span class="o">.</span><span class="n">eventFilter</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">keysequence</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># If we are in this branch then no more macros are left</span>
                    <span class="c"># to run. So trigger the focus manager one more time</span>
                    <span class="c"># and then leave the while-loop.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_qteFocusManager</span><span class="p">()</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteFocusManager</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">timerId</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugTimer</span><span class="p">:</span>
            <span class="c">#win = self.qteNextWindow()</span>
            <span class="c">#self.qteMakeWindowActive(win)</span>
            <span class="c">#self.debugTimer = self.startTimer(1000)</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Should not happen.</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Unknown timer ID&#39;</span><span class="p">)</span>
            <span class="k">pass</span>
</div>
    <span class="k">def</span> <span class="nf">_qteFocusManager</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give the focus to the correct applet and widget.</span>

<span class="sd">        This method is the only method in all of Qtmacs that actually</span>
<span class="sd">        instructs the Qt library to focus a widget. It does so by</span>
<span class="sd">        first synchronising what Qtmacs thinks is visible and what Qt</span>
<span class="sd">        knows is visible, and then make the applet/widget active for</span>
<span class="sd">        which ``qteMakeAppletActive`` and/or ``qteMakeWidgetActive``</span>
<span class="sd">        were called last. If these applets do not exist anymore, then</span>
<span class="sd">        the next possible widget and or applet will be chosen.</span>

<span class="sd">        To trigger the focus manger *do not call this method</span>
<span class="sd">        directly*, but use ``qteUpdate`` instead. This ensures that</span>
<span class="sd">        the focus manager only runs *after* the Qt event loop was able</span>
<span class="sd">        to show/hide all the widgets and update internal status variables</span>
<span class="sd">        like the Qt native ``isVisible``.</span>

<span class="sd">        This method also performs several sanity checks to ensure that</span>
<span class="sd">        all visible applets are part of a splitter while all invisible</span>
<span class="sd">        applets are not. Violations of this rule are reported and</span>
<span class="sd">        should be debugged, as otherwise floating applets are a</span>
<span class="sd">        possibility.</span>

<span class="sd">        The focus policy:</span>
<span class="sd">        ------------------</span>

<span class="sd">        Facts:</span>

<span class="sd">          * There are windows, applets in windows, and widgets in</span>
<span class="sd">            applets.</span>
<span class="sd">          * The currently active applet is</span>
<span class="sd">            QtmacsMain._qteActiveApplet.</span>
<span class="sd">          * The currently active widget inside that applet is</span>
<span class="sd">            QtmacsApplet._qteActiveWidget.</span>
<span class="sd">          * No one except the focus manager calls the Qt native</span>
<span class="sd">            ``setFocus`` or ``activateWindow`` methods.</span>
<span class="sd">          * To queue an applet/widget for activation call</span>
<span class="sd">            ``qteMake{Applet,Widget}Active``. This will update the</span>
<span class="sd">            aforementioned variables ``_qteActiveApplet`` and</span>
<span class="sd">            ``_qteActiveWidget`` attributes in ``QtmacsMain`` and</span>
<span class="sd">            ``QtmacsApplet``, respectively.</span>
<span class="sd">          * The focus manager will inspect these variables and make</span>
<span class="sd">            the specified applet and widget active, if they still</span>
<span class="sd">            exists. If they do not exists, it will automatically pick</span>
<span class="sd">            a substitute.</span>

<span class="sd">        The tasks of the focus manager are, in this order:</span>

<span class="sd">          * Ensure Qt and Qtmacs agree on what is currently visible and</span>
<span class="sd">            go into damage control if this does not check out.</span>
<span class="sd">          * Activate the top level window containing ``_qteActiveApplet``.</span>
<span class="sd">          * Focus the active widget ``_qteActiveWidget`` inside the applet.</span>


<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Process all but user input events.</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QEventLoop</span><span class="o">.</span><span class="n">ExcludeUserInputEvents</span>
        <span class="n">qApp</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>
        <span class="n">qApp</span><span class="o">.</span><span class="n">processEvents</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

        <span class="c"># Ensure _qteActiveApplet is not a dangling pointer.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sip</span><span class="o">.</span><span class="n">isdeleted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Perform sanity checks on all applets.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Compile a list of visible and invisible applets (include</span>
            <span class="c"># the mini applet).</span>
            <span class="n">isVis</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span> <span class="k">if</span> <span class="n">_</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">()]</span>
            <span class="n">isNotVis</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">()]</span>

            <span class="c"># Ensure that the parent of every visible applet is a</span>
            <span class="c"># QtmacsSplitter instance.</span>
            <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="n">isVis</span><span class="p">:</span>
                <span class="n">signatureParent</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span>
                <span class="k">if</span> <span class="n">signatureParent</span> <span class="o">!=</span> <span class="s">&#39;__QtmacsLayoutSplitter__&#39;</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Applet &lt;b&gt;{}&lt;/b&gt; is visible but not in splitter.&#39;</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># Ensure all invisible applets have no parent.</span>
            <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="n">isNotVis</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Applet &lt;b&gt;{}&lt;/b&gt; is invisible yet has a parent.&#39;</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># Ensure that Qt and Qtmacs agree on whether or not an</span>
            <span class="c"># applet is visible.</span>
            <span class="n">isFaulty</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">isVisible</span><span class="p">()</span> <span class="o">!=</span> <span class="n">_</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">())):</span>
                <span class="n">isFaulty</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Inconsistent visibility for applet &lt;b&gt;{}&lt;/b&gt;.&#39;</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">())</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; Qt: {}, Qtmacs: {}&#39;</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">isVisible</span><span class="p">(),</span> <span class="n">app</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># If one or more visibility inconsistencies occurred then</span>
            <span class="c"># go into damage control and reset the layout as best as</span>
            <span class="c"># possible.</span>
            <span class="k">if</span> <span class="n">isFaulty</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Resetting applet layout due to visibility&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; inconsistencies.&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="c"># Close all but the first window.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">window</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="c"># Hide all applets except the mini applet. Note that</span>
                <span class="c"># the hide() method will reparent the widget to None</span>
                <span class="c"># which implies that they are also removed from any</span>
                <span class="c"># they might be in.</span>
                <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span>
                            <span class="k">if</span> <span class="n">_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">):</span>
                    <span class="n">app</span><span class="o">.</span><span class="n">hide</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

                <span class="c"># Manually insert the first applet into the splitter</span>
                <span class="c"># and make it visible.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># If the _qteActiveApplet pointer is void try to assign it</span>
        <span class="c"># another applet, even if it is just the mini applet. If</span>
        <span class="c"># nothing is available, then return.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span>
                    <span class="n">numSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipMiniApplet</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Activate the Qt window that harbours the applet and is only</span>
        <span class="c"># relevant if multiple windows are open. The activation is</span>
        <span class="c"># necessary because giving the focus to a any widget (an</span>
        <span class="c"># applet in this case) does not automatically active the</span>
        <span class="c"># window it is in (see Qt documentation for more details).</span>
        <span class="c"># This is the only place in Qtmacs where the Qt libraray is</span>
        <span class="c"># actually instructed to activate a window.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span><span class="o">.</span><span class="n">activateWindow</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Qt had a serious problem activating a window&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; --&gt; try to reproduce.&#39;</span>
            <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Raised error:&#39;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Current applet&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s">&#39;Tried to focus a non-existing applet.&#39;</span><span class="p">,</span>
                                     <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Shorthand.</span>
        <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteMakeAppletActive</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Activate the next focusable widget in the applet. Note that</span>
        <span class="c"># the qteMakeWidgetActive method</span>
        <span class="c">#   * can cope with nextWidget being None,</span>
        <span class="c">#   * does not actually set the focus of anything but only</span>
        <span class="c">#     asks Qtmacs to do it. The actual focussing is done</span>
        <span class="c">#     a few lines further down.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="n">wid</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">qteNextWidget</span><span class="p">(</span><span class="n">numSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">app</span><span class="o">.</span><span class="n">qteMakeWidgetActive</span><span class="p">(</span><span class="n">wid</span><span class="p">)</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># Actually focus the active widget in the active applet. This</span>
        <span class="c"># is the only place in Qtmacs where the Qt library is actually</span>
        <span class="c"># instructed to focus a widget.</span>
        <span class="c"># ------------------------------------------------------------</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">_qteActiveWidget</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">app</span><span class="o">.</span><span class="n">setFocus</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">OtherFocusReason</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">app</span><span class="o">.</span><span class="n">_qteActiveWidget</span><span class="o">.</span><span class="n">setFocus</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">OtherFocusReason</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Serious problem activating the applet --&gt; &#39;</span>
                  <span class="s">&#39;try to reproduce.&#39;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Raised error:&#39;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Current applet object&#39;</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Next widget: &#39;</span><span class="p">,</span> <span class="n">nextWidget</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Current applet ID&#39;</span><span class="p">,</span> <span class="n">app</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">())</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Active widget inside this applet&#39;</span><span class="p">,</span> <span class="n">app</span><span class="o">.</span><span class="n">_qteActiveWidget</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s">&#39;Tried to focus a non-existing applet.&#39;</span><span class="p">,</span>
                                     <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_qteMouseClicked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the Qtmacs internal focus state as the result of a mouse click.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``new`` (**QWidget**): the widget that received the focus.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># The following cases for widgetObj have to be distinguished:</span>
        <span class="c">#   1: not part of the Qtmacs widget hierarchy</span>
        <span class="c">#   2: part of the Qtmacs widget hierarchy but not registered</span>
        <span class="c">#   3: registered with Qtmacs and an applet</span>
        <span class="c">#   4: registered with Qtmacs and anything but an applet</span>
        <span class="c"># ------------------------------------------------------------</span>

        <span class="c"># Case 1: return immediately if widgetObj is not part of the</span>
        <span class="c"># Qtmacs widget hierarchy; otherwise, declare the applet</span>
        <span class="c"># containing the widgetObj active.</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">qteGetAppletFromWidget</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="n">app</span>

        <span class="c"># Case 2: unregistered widgets are activated immediately.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">,</span> <span class="s">&#39;_qteAdmin&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span><span class="o">.</span><span class="n">qteMakeWidgetActive</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">isQtmacsApplet</span><span class="p">:</span>
                <span class="c"># Case 3: widgetObj is a QtmacsApplet instance; do not</span>
                <span class="c"># focus any of its widgets as the focus manager will</span>
                <span class="c"># take care of it.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span><span class="o">.</span><span class="n">qteMakeWidgetActive</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Case 4: widgetObj was registered with qteAddWidget</span>
                <span class="c"># and can thus be focused directly.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span><span class="o">.</span><span class="n">qteMakeWidgetActive</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">)</span>

        <span class="c"># Trigger the focus manager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteFocusManager</span><span class="p">()</span>

<div class="viewcode-block" id="QtmacsMain.qteFocusChanged"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteFocusChanged">[docs]</a>    <span class="k">def</span> <span class="nf">qteFocusChanged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slot for Qt native focus-changed signal to notify Qtmacs if</span>
<span class="sd">        the window was switched.</span>

<span class="sd">        .. note: This method is work in progress.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Do nothing if new is old.</span>
        <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="n">new</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># If neither is None but both have the same top level</span>
        <span class="c"># window then do nothing.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">old</span><span class="o">.</span><span class="n">isActiveWindow</span><span class="p">()</span> <span class="ow">is</span> <span class="n">new</span><span class="o">.</span><span class="n">isActiveWindow</span><span class="p">():</span>
                <span class="k">return</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteUpdate"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteUpdate">[docs]</a>    <span class="k">def</span> <span class="nf">qteUpdate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trigger the focus manager to update all widgets once the event</span>
<span class="sd">        loop is in control again.</span>

<span class="sd">        It is safe to call this method multiple times. Qtmacs ensures</span>
<span class="sd">        that the focus manager is only triggered once.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteTimerRunMacro</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteTimerRunMacro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">startTimer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="QtmacsMain.QtmacsExceptHook"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.QtmacsExceptHook">[docs]</a>    <span class="k">def</span> <span class="nf">QtmacsExceptHook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Error handler for all errors that are not captured inside</span>
<span class="sd">        Qtmacs.</span>

<span class="sd">        This handler substitutes the ``sys.excepthook`` which is</span>
<span class="sd">        called whenever an error propagates all the way up to the</span>
<span class="sd">        interpreter. This hook should only be invoked rarely because</span>
<span class="sd">        all the macros in Qtmacs are executed within a try/catch</span>
<span class="sd">        statement, but if a faulty code is not triggered by Qtmacs</span>
<span class="sd">        itself but eg. one of its signals, or an external event, then</span>
<span class="sd">        the error cannot be caught directly. Instead, Qtmacs re-routed</span>
<span class="sd">        these error to this method which feeds them into the logger</span>
<span class="sd">        module like any other message.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``exc_info`` (**tuple**): native error information and stack</span>
<span class="sd">          trace.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;*** Global Error ***&#39;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc_info</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteIsMiniApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteIsMiniApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteIsMiniApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if instance ``obj`` is a mini applet.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``obj`` (**object**): object to test.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: whether or not ``obj`` is the mini applet.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">isMiniApplet</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="n">ret</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteNewWindow"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteNewWindow">[docs]</a>    <span class="k">def</span> <span class="nf">qteNewWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QRect</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">windowID</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new, empty window with ``windowID`` at position ``pos``.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``pos`` (**QRect**): size and position of new window.</span>
<span class="sd">        * ``windowID`` (**str**): unique window ID.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsWindow**: reference to the just created window instance.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Compile a list of all window IDs.</span>
        <span class="n">winIDList</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">_qteWindowID</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">]</span>

        <span class="c"># If no window ID was supplied simply count until a new and</span>
        <span class="c"># unique ID was found.</span>
        <span class="k">if</span> <span class="n">windowID</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">str</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="ow">in</span> <span class="n">winIDList</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">windowID</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>

        <span class="c"># If no position was specified use a default one.</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QRect</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>

        <span class="c"># Raise an error if a window with this ID already exists.</span>
        <span class="k">if</span> <span class="n">windowID</span> <span class="ow">in</span> <span class="n">winIDList</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Window with ID &lt;b&gt;{}&lt;/b&gt; already exists.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">windowID</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">QtmacsOtherError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c"># Instantiate a new window object.</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">QtmacsWindow</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">windowID</span><span class="p">)</span>

        <span class="c"># Add the new window to the window list and make it visible.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
        <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c"># Trigger the focus manager once the event loop is in control again.</span>
        <span class="k">return</span> <span class="n">window</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteMakeWindowActive"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteMakeWindowActive">[docs]</a>    <span class="k">def</span> <span class="nf">qteMakeWindowActive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windowObj</span><span class="p">:</span> <span class="n">QtmacsWindow</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make the window ``windowObj`` active and focus the first</span>
<span class="sd">        applet therein.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``windowObj`` (**QtmacsWindow**): window to activate.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">:</span>
            <span class="c"># This will trigger the focusChanged slot which, in</span>
            <span class="c"># conjunction with the focus manager, will take care of</span>
            <span class="c"># the rest. Note that ``activateWindow`` is a native Qt</span>
            <span class="c"># method, not a Qtmacs invention.</span>
            <span class="n">windowObj</span><span class="o">.</span><span class="n">activateWindow</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Window to activate does not exist&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteActiveWindow"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteActiveWindow">[docs]</a>    <span class="k">def</span> <span class="nf">qteActiveWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the currently active ``QtmacsWindow`` object.</span>

<span class="sd">        If no Qtmacs window is currently active (for instance because</span>
<span class="sd">        the user is working with another application at the moment)</span>
<span class="sd">        then the method returns the first window in the window list.</span>

<span class="sd">        The method only returns **None** if the window list is empty,</span>
<span class="sd">        which is definitively a bug.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsWindow**: the currently active window or **None** if</span>
<span class="sd">          no window is currently active.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&#39;The window list is empty.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Find the active window.</span>
            <span class="k">for</span> <span class="n">win</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">win</span><span class="o">.</span><span class="n">isActiveWindow</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">win</span>

        <span class="c"># Return the first window if none is active.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteNextWindow"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteNextWindow">[docs]</a>    <span class="k">def</span> <span class="nf">qteNextWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return next window in cyclic order.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsWindow**: the next window in the Qtmacs internal</span>
<span class="sd">            window list.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Get the currently active window.</span>
        <span class="n">win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteActiveWindow</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">win</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">:</span>
            <span class="c"># Find the index of the window in the window list and</span>
            <span class="c"># cyclically move to the next element in this list to find</span>
            <span class="c"># the next window object.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;qteNextWindow method found a non-existing window.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteKillWindow"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteKillWindow">[docs]</a>    <span class="k">def</span> <span class="nf">qteKillWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windowObj</span><span class="p">:</span> <span class="n">QtmacsWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kill the specified window (applets inside the window are not</span>
<span class="sd">        deleted).</span>

<span class="sd">        .. note:: The method does nothing if ``windowObj`` is the only</span>
<span class="sd">           window left.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * *windowObj* (**QtmacsWindow**): window object to delete.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Use the currently active window if none was specified.</span>
        <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">windowObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteActiveWindow</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Cannot kill the currently active window because&#39;</span>
                       <span class="s">&#39; it does not exist&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="c"># If Qtmacs shows only one window then do nothing, because</span>
        <span class="c"># deleting this window is akin to quitting Qtmacs without</span>
        <span class="c"># going through the proper shutdown process.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;The last available window cannot be deleted.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># Remove the window from the list.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">windowObj</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Cannot delete window with ID &lt;b&gt;{}&lt;/b&gt; because it&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; does not exist.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">windowObj</span><span class="o">.</span><span class="n">_qteWindowID</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># Shorthand</span>
        <span class="n">activeWindow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteActiveWindow</span><span class="p">()</span>

        <span class="c"># If the window to delete is currently active then switch the</span>
        <span class="c"># focus to the first window in the list (not particularly</span>
        <span class="c"># smart, but will do for now).</span>
        <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="n">activeWindow</span><span class="p">:</span>
            <span class="n">activeWindow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activeWindow</span><span class="o">.</span><span class="n">activateWindow</span><span class="p">()</span>

            <span class="c"># Since the window with the active applet is deleted,</span>
            <span class="c"># try to find a new applet to activate instead. It is</span>
            <span class="c"># ok if there is no such applet.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span>
                <span class="n">windowObj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c"># Move the mini applet if it is currently in the doomed</span>
        <span class="c"># window.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">qteParentWindow</span><span class="p">()</span> <span class="ow">is</span> <span class="n">windowObj</span><span class="p">:</span>
                <span class="c"># Re-parent the mini applet to the splitter in the new</span>
                <span class="c"># window.</span>
                <span class="n">activeWindow</span><span class="o">.</span><span class="n">qteLayoutSplitter</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

                <span class="c"># Give the focus to the first focusable widget (if any).</span>
                <span class="n">wid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">qteNextWidget</span><span class="p">(</span><span class="n">numSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">qteMakeWidgetActive</span><span class="p">(</span><span class="n">wid</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteMakeAppletActive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">)</span>

        <span class="c"># Compile the list of visible applets in the doomed window</span>
        <span class="c"># (use ``qteParentWindow`` to find all applets that have the</span>
        <span class="c"># doomed window as parent).</span>
        <span class="n">app_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span>
                    <span class="k">if</span> <span class="n">_</span><span class="o">.</span><span class="n">qteParentWindow</span><span class="p">()</span> <span class="o">==</span> <span class="n">windowObj</span><span class="p">]</span>

        <span class="c"># Hide all visible applets in the doomed window. Do not use</span>
        <span class="c"># ``qteRemoveFromLayout`` for this since that method attempts</span>
        <span class="c"># to replace the removed applet with another one, ie. the</span>
        <span class="c"># doomed window would once again contain an applet.</span>
        <span class="k">for</span> <span class="n">app_obj</span> <span class="ow">in</span> <span class="n">app_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteIsMiniApplet</span><span class="p">(</span><span class="n">app_obj</span><span class="p">):</span>
                <span class="n">app_obj</span><span class="o">.</span><span class="n">hide</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Ensure the focus manager is triggered and the window deleted</span>
        <span class="c"># once the event loop has regained control.</span>
        <span class="n">windowObj</span><span class="o">.</span><span class="n">deleteLater</span><span class="p">()</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteNextApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteNextApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteNextApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numSkip</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ofsApp</span><span class="p">:</span> <span class="p">(</span><span class="n">QtmacsApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">skipInvisible</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skipVisible</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                      <span class="n">skipMiniApplet</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                      <span class="n">windowObj</span><span class="p">:</span> <span class="n">QtmacsWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the next applet in cyclic order.</span>

<span class="sd">        If ``ofsApp=None`` then start cycling at the currently active</span>
<span class="sd">        applet. If ``ofsApp`` does not fit the selection criteria,</span>
<span class="sd">        then the cycling starts at the next applet in cyclic order</span>
<span class="sd">        that does.</span>

<span class="sd">        The returned applet is ``numSkip`` items in cyclic order away</span>
<span class="sd">        from the offset applet. If ``numSkip`` is positive traverse</span>
<span class="sd">        the applet list forwards, otherwise backwards.</span>

<span class="sd">        The method supports the following Boolean selection criteria:</span>

<span class="sd">        * ``skipInvisible``: ignore all invisible applets.</span>
<span class="sd">        * ``skipVisible``: ignore all visible applets.</span>
<span class="sd">        * ``skipMiniApplet``: ignore the mini applet applet.</span>

<span class="sd">        The ``ofsApp`` parameter can either be an instance of</span>
<span class="sd">        ``QtmacsApplet`` or a string denoting an applet ID. In the</span>
<span class="sd">        latter case the ``qteGetAppletHandle`` method is used to fetch</span>
<span class="sd">        the respective applet instance.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``numSkip`` (**int**): number of applets to skip.</span>
<span class="sd">        * ``ofsApp`` (**QtmacsApplet**, **str**): applet from where to</span>
<span class="sd">          start counting.</span>
<span class="sd">        * ``skipInvisible`` (**bool**): whether or not to skip currently</span>
<span class="sd">          not shown applets.</span>
<span class="sd">        * ``skipVisible`` (**bool**): whether or not to skip currently</span>
<span class="sd">          shown applets.</span>
<span class="sd">        * ``skipMiniApplet`` (**bool**): whether or not to skip the mini</span>
<span class="sd">          applet.</span>
<span class="sd">        * ``windowObj`` (**QtmacsWindow**): the window to use when looking</span>
<span class="sd">          for applets. If **None**, then search in all windows.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsApplet**: either the next applet that fits the criteria,</span>
<span class="sd">          or **None** if no such applet exists.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If ``applet`` was specified by its ID (ie. a string) then</span>
        <span class="c"># fetch the associated ``QtmacsApplet`` instance. If</span>
        <span class="c"># ``applet`` is already an instance of ``QtmacsApplet`` then</span>
        <span class="c"># use it directly.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ofsApp</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">ofsApp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">ofsApp</span><span class="p">)</span>

        <span class="c"># Return immediately if the applet list is empty.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Sanity check: if the user requests applets that are neither</span>
        <span class="c"># visible nor invisible then return immediately because no</span>
        <span class="c"># such applet can possibly exist.</span>
        <span class="k">if</span> <span class="n">skipVisible</span> <span class="ow">and</span> <span class="n">skipInvisible</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Make a copy of the applet list.</span>
        <span class="n">appList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">)</span>

        <span class="c"># Remove all invisible applets from the list if the</span>
        <span class="c"># skipInvisible flag is set.</span>
        <span class="k">if</span> <span class="n">skipInvisible</span><span class="p">:</span>
            <span class="n">appList</span> <span class="o">=</span> <span class="p">[</span><span class="n">app</span> <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="n">appList</span> <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">()]</span>

            <span class="c"># From the list of (now guaranteed visible) applets remove</span>
            <span class="c"># all those that are not in the specified window.</span>
            <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">appList</span> <span class="o">=</span> <span class="p">[</span><span class="n">app</span> <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="n">appList</span>
                           <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">qteParentWindow</span><span class="p">()</span> <span class="o">==</span> <span class="n">windowObj</span><span class="p">]</span>

        <span class="c"># Remove all visible applets from the list if the</span>
        <span class="c"># skipInvisible flag is set.</span>
        <span class="k">if</span> <span class="n">skipVisible</span><span class="p">:</span>
            <span class="n">appList</span> <span class="o">=</span> <span class="p">[</span><span class="n">app</span> <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="n">appList</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">app</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">()]</span>

        <span class="c"># If the mini-buffer is to be skipped remove it (if a custom</span>
        <span class="c"># mini applet even exists).</span>
        <span class="k">if</span> <span class="n">skipMiniApplet</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span> <span class="ow">in</span> <span class="n">appList</span><span class="p">:</span>
                <span class="n">appList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">)</span>

        <span class="c"># Return immediately if no applet satisfied all criteria.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">appList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># If no offset applet was given use the currently active one.</span>
        <span class="k">if</span> <span class="n">ofsApp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ofsApp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span>

        <span class="k">if</span> <span class="n">ofsApp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">:</span>
            <span class="c"># Determine if the offset applet is part of the pruned</span>
            <span class="c"># list.</span>
            <span class="k">if</span> <span class="n">ofsApp</span> <span class="ow">in</span> <span class="n">appList</span><span class="p">:</span>
                <span class="c"># Yes: determine its index in the list.</span>
                <span class="n">ofsIdx</span> <span class="o">=</span> <span class="n">appList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ofsApp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># No: traverse all applets until one is found that is</span>
                <span class="c"># also part of the pruned list (start at ofsIdx). Then</span>
                <span class="c"># determine its index in the list.</span>
                <span class="n">ofsIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ofsApp</span><span class="p">)</span>
                <span class="n">glob_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">[</span><span class="n">ofsIdx</span><span class="p">:]</span>
                <span class="n">glob_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">[:</span><span class="n">ofsIdx</span><span class="p">]</span>

                <span class="c"># Compile the intersection between the global and pruned list.</span>
                <span class="n">ofsIdx</span> <span class="o">=</span> <span class="p">[</span><span class="n">appList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">glob_list</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">appList</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ofsIdx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;No match between global and local applet list&#39;</span>
                           <span class="s">&#39; --&gt; Bug.&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Pick the first match.</span>
                    <span class="n">ofsIdx</span> <span class="o">=</span> <span class="n">ofsIdx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># The offset applet does not exist, eg. because the user</span>
            <span class="c"># supplied a handle that does not point to an applet or</span>
            <span class="c"># we are called from qteKillApplet to replace the just</span>
            <span class="c"># removed (and active) applet.</span>
            <span class="n">ofsIdx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Compute the index of the next applet and wrap around the</span>
        <span class="c"># list if necessary.</span>
        <span class="n">ofsIdx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ofsIdx</span> <span class="o">+</span> <span class="n">numSkip</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">appList</span><span class="p">)</span>

        <span class="c"># Return a handle to the applet that meets the specified</span>
        <span class="c"># criteria.</span>
        <span class="k">return</span> <span class="n">appList</span><span class="p">[</span><span class="n">ofsIdx</span><span class="p">]</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteRunMacro"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteRunMacro">[docs]</a>    <span class="k">def</span> <span class="nf">qteRunMacro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">macroName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">:</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">keysequence</span><span class="p">:</span> <span class="n">QtmacsKeysequence</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queue a previously registered macro for execution once the</span>
<span class="sd">        event loop is idle.</span>

<span class="sd">        The reason for queuing macros in the first place, instead of</span>
<span class="sd">        running them straight away, is to ensure that the event loop</span>
<span class="sd">        updates all the widgets in between any two macros. This will</span>
<span class="sd">        avoid many spurious and hard to find bugs due to macros</span>
<span class="sd">        assuming that all user interface elements have been updated</span>
<span class="sd">        when in fact they were not.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``macroName`` (**str**): name of macro.</span>
<span class="sd">        * ``widgetObj`` (**QWidget**): widget (if any) on which the</span>
<span class="sd">          macro should operate.</span>
<span class="sd">        * ``keysequence`` (**QtmacsKeysequence**): key sequence that</span>
<span class="sd">          triggered the macro.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Add the new macro to the queue and call qteUpdate to ensure</span>
        <span class="c"># that the macro is processed once the event loop is idle again.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMacroQueue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">macroName</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">,</span> <span class="n">keysequence</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteUpdate</span><span class="p">()</span>
</div>
    <span class="nd">@type_check</span>
    <span class="k">def</span> <span class="nf">_qteRunQueuedMacro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">macroName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">widgetObj</span><span class="p">:</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">keysequence</span><span class="p">:</span> <span class="n">QtmacsKeysequence</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the next macro in the macro queue.</span>

<span class="sd">        This method is triggered by the ``timerEvent`` in conjunction</span>
<span class="sd">        with the focus manager to ensure the event loop updates the</span>
<span class="sd">        GUI in between any two macros.</span>

<span class="sd">        .. warning:: Never call this method directly.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``macroName`` (**str**): name of macro</span>
<span class="sd">        * ``widgetObj`` (**QWidget**): widget (if any) for which the</span>
<span class="sd">          macro applies</span>
<span class="sd">        * ``keysequence* (**QtmacsKeysequence**): key sequence that</span>
<span class="sd">          triggered the macro.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Fetch the applet holding the widget (this may be None).</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">qteGetAppletFromWidget</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">)</span>

        <span class="c"># Double check that the applet still exists, unless there is</span>
        <span class="c"># no applet (can happen when the windows are empty).</span>
        <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sip</span><span class="o">.</span><span class="n">isdeleted</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Ignored macro &lt;b&gt;{}&lt;/b&gt; because it targeted a&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;  nonexistent applet.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroName</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="c"># Fetch a signature compatible macro object.</span>
        <span class="n">macroObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetMacroObject</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">)</span>

        <span class="c"># Log an error if no compatible macro was found.</span>
        <span class="k">if</span> <span class="n">macroObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;No &lt;b&gt;{}&lt;/b&gt;-macro compatible with {}:{}-type applet&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">app</span><span class="o">.</span><span class="n">qteAppletSignature</span><span class="p">(),</span>
                             <span class="n">widgetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># Update the &#39;last_key_sequence&#39; variable in case the macros,</span>
        <span class="c"># or slots triggered by that macro, have access to it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteDefVar</span><span class="p">(</span><span class="s">&#39;last_key_sequence&#39;</span><span class="p">,</span> <span class="n">keysequence</span><span class="p">,</span>
                       <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Last valid key sequence that triggered a macro.&quot;</span><span class="p">)</span>

        <span class="c"># Set some variables in the macro object for convenient access</span>
        <span class="c"># from inside the macro.</span>
        <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">macroObj</span><span class="o">.</span><span class="n">qteApplet</span> <span class="o">=</span> <span class="n">macroObj</span><span class="o">.</span><span class="n">qteWidget</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">macroObj</span><span class="o">.</span><span class="n">qteApplet</span> <span class="o">=</span> <span class="n">app</span>
            <span class="n">macroObj</span><span class="o">.</span><span class="n">qteWidget</span> <span class="o">=</span> <span class="n">widgetObj</span>

        <span class="c"># Run the macro and trigger the focus manager.</span>
        <span class="n">macroObj</span><span class="o">.</span><span class="n">qtePrepareToRun</span><span class="p">()</span>

    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteNewApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteNewApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteNewApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appletName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">appletID</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">windowObj</span><span class="p">:</span> <span class="n">QtmacsWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new instance of ``appletName`` and assign it the</span>
<span class="sd">        ``appletID``.</span>

<span class="sd">        This method creates a new instance of ``appletName``, as</span>
<span class="sd">        registered by the ``qteRegisterApplet`` method. If an applet</span>
<span class="sd">        with ``appletID`` already exists then the method does nothing</span>
<span class="sd">        and returns **None**, otherwise the newly created instance.</span>

<span class="sd">        If ``appletID`` is **None** then the method will create an</span>
<span class="sd">        applet with the next unique ID that fits the format</span>
<span class="sd">        ``appletName_0``, eg. &#39;RichEditor_0&#39;, &#39;RichEditor_1&#39;, etc.</span>

<span class="sd">        .. note:: The applet is not automatically made visible.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``appletName`` (**str**): name of applet to create</span>
<span class="sd">          (eg. &#39;LogViewer&#39;)</span>
<span class="sd">        * ``appletID`` (**str**): unique applet identifier.</span>
<span class="sd">        * ``windowObj`` (**QtmacsWindow**): the window in which</span>
<span class="sd">          the applet should be created.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsApplet**: applet handle or **None** if no applet</span>
<span class="sd">          was created.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Use the currently active window if none was specified.</span>
        <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">windowObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteActiveWindow</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Cannot determine the currently active window.&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="c"># Determine an automatic applet ID if none was provided.</span>
        <span class="k">if</span> <span class="n">appletID</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">appletID</span> <span class="o">=</span> <span class="n">appletName</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">appletID</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Return immediately if an applet with the same ID already</span>
        <span class="c"># exists.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">appletID</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Applet with ID &lt;b&gt;{}&lt;/b&gt; already exists&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">appletID</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Verify that the requested applet class was registered</span>
        <span class="c"># beforehand and fetch it.</span>
        <span class="k">if</span> <span class="n">appletName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryApplets</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Unknown applet &lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">appletName</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryApplets</span><span class="p">[</span><span class="n">appletName</span><span class="p">]</span>

        <span class="c"># Try to instantiate the class.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">app</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">appletID</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Applet &lt;b&gt;{}&lt;/b&gt; has a faulty constructor.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">appletID</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Ensure the applet class has an applet signature.</span>
        <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">qteAppletSignature</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Cannot add applet &lt;b&gt;{}&lt;/b&gt; &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">())</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;because it has not applet signature.&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; Use self.qteSetAppletSignature in the constructor&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; of the class to fix this.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Add the applet to the list of instantiated Qtmacs applets.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>

        <span class="c"># If the new applet does not yet have an internal layout then</span>
        <span class="c"># arrange all its children automatically. The layout used for</span>
        <span class="c"># this is horizontal and the widgets are added in the order in</span>
        <span class="c"># which they were registered with Qtmacs.</span>
        <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">layout</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">appLayout</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QHBoxLayout</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">app</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetList</span><span class="p">:</span>
                <span class="n">appLayout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
            <span class="n">app</span><span class="o">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">appLayout</span><span class="p">)</span>

        <span class="c"># Initially, the window does not have a parent. A parent will</span>
        <span class="c"># be assigned automatically once the applet is made visible,</span>
        <span class="c"># in which case it is re-parented into a QtmacsSplitter.</span>
        <span class="n">app</span><span class="o">.</span><span class="n">qteReparent</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

        <span class="c"># Emit the init hook for this applet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteRunHook</span><span class="p">(</span><span class="s">&#39;init&#39;</span><span class="p">,</span> <span class="n">QtmacsMessage</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">app</span><span class="p">))</span>

        <span class="c"># Return applet handle.</span>
        <span class="k">return</span> <span class="n">app</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteAddMiniApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteAddMiniApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteAddMiniApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appletObj</span><span class="p">:</span> <span class="n">QtmacsApplet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Install ``appletObj`` as the mini applet in the window layout.</span>

<span class="sd">        At any given point there can ever only be one mini applet in</span>
<span class="sd">        the entire Qtmacs application, irrespective of how many</span>
<span class="sd">        windows are open.</span>

<span class="sd">        Note that this method does nothing if a custom mini applet is</span>
<span class="sd">        already active. Use ``qteKillMiniApplet`` to remove that one</span>
<span class="sd">        first before installing a new one.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``appletObj`` (**QtmacsApplet**): the new mini applet.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: if **True** the mini applet was installed</span>
<span class="sd">          successfully.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Do nothing if a custom mini applet has already been</span>
        <span class="c"># installed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Cannot replace mini applet more than once.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Arrange all registered widgets inside this applet</span>
        <span class="c"># automatically if the mini applet object did not install its</span>
        <span class="c"># own layout.</span>
        <span class="k">if</span> <span class="n">appletObj</span><span class="o">.</span><span class="n">layout</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">appLayout</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QHBoxLayout</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">appletObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetList</span><span class="p">:</span>
                <span class="n">appLayout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
            <span class="n">appletObj</span><span class="o">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">appLayout</span><span class="p">)</span>

        <span class="c"># Now that we have decided to install this mini applet, keep a</span>
        <span class="c"># reference to it and set the mini applet flag in the</span>
        <span class="c"># applet. This flag is necessary for some methods to separate</span>
        <span class="c"># conventional applets from mini applets.</span>
        <span class="n">appletObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">isMiniApplet</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span> <span class="o">=</span> <span class="n">appletObj</span>

        <span class="c"># Shorthands.</span>
        <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span>
        <span class="n">appWin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteActiveWindow</span><span class="p">()</span>

        <span class="c"># Remember which window and applet spawned this mini applet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">_qteCallingApplet</span> <span class="o">=</span> <span class="n">app</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">_qteCallingWindow</span> <span class="o">=</span> <span class="n">appWin</span>
        <span class="k">del</span> <span class="n">app</span>

        <span class="c"># Add the mini applet to the applet registry, ie. for most</span>
        <span class="c"># purposes the mini applet is treated like any other applet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">)</span>

        <span class="c"># Add the mini applet to the respective splitter in the window</span>
        <span class="c"># layout and show it.</span>
        <span class="n">appWin</span><span class="o">.</span><span class="n">qteLayoutSplitter</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Give focus to first focusable widget in the mini applet</span>
        <span class="c"># applet (if one exists)</span>
        <span class="n">wid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">qteNextWidget</span><span class="p">(</span><span class="n">numSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">qteMakeWidgetActive</span><span class="p">(</span><span class="n">wid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteMakeAppletActive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">)</span>

        <span class="c"># Mini applet was successfully installed.</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteKillMiniApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteKillMiniApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteKillMiniApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the mini applet.</span>

<span class="sd">        If a different applet is to be restored/focused then call</span>
<span class="sd">        ``qteMakeAppletActive`` for that applet *after* calling this</span>
<span class="sd">        method.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Sanity check: is the handle valid?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># Sanity check: is it really a mini applet?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteIsMiniApplet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Mini applet does not have its mini applet flag set.&#39;</span>
                   <span class="s">&#39; Ignored.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">:</span>
            <span class="c"># Something is wrong because the mini applet is not part</span>
            <span class="c"># of the applet list.</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Custom mini applet not in applet list --&gt; Bug.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Inform the mini applet that it is about to be killed.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">qteToBeKilled</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;qteToBeKilledRoutine is faulty&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># Shorthands to calling window.</span>
            <span class="n">win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">_qteCallingWindow</span>

            <span class="c"># We need to move the focus from the mini applet back to a</span>
            <span class="c"># regular applet. Therefore, first look for the next</span>
            <span class="c"># visible applet in the current window (ie. the last one</span>
            <span class="c"># that was made active).</span>
            <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span><span class="n">windowObj</span><span class="o">=</span><span class="n">win</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># Found another (visible or invisible) applet --&gt; make</span>
                <span class="c"># it active/visible.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteMakeAppletActive</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># No visible applet available in this window --&gt; look</span>
                <span class="c"># for an invisible one.</span>
                <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span><span class="n">skipInvisible</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">skipVisible</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c"># Found an invisible applet --&gt; make it</span>
                    <span class="c"># active/visible.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qteMakeAppletActive</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># There is no other visible applet in this window.</span>
                    <span class="c"># The focus manager will therefore make a new applet</span>
                    <span class="c"># active.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">)</span>

        <span class="c"># Close the mini applet applet and schedule it for deletion.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="o">.</span><span class="n">deleteLater</span><span class="p">()</span>

        <span class="c"># Clear the handle to the mini applet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span> <span class="o">=</span> <span class="bp">None</span>
</div>
    <span class="nd">@type_check</span>
    <span class="k">def</span> <span class="nf">_qteFindAppletInSplitter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appletObj</span><span class="p">:</span> <span class="n">QtmacsApplet</span><span class="p">,</span>
                                 <span class="n">split</span><span class="p">:</span> <span class="n">QtmacsSplitter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the splitter that holds ``appletObj``.</span>

<span class="sd">        This method recursively searches for ``appletObj`` in the</span>
<span class="sd">        nested splitter hierarchy of the window layout, starting at</span>
<span class="sd">        ``split``. If successful, the method returns a reference to</span>
<span class="sd">        the splitter, otherwise it returns **None**.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``appletObj`` (**QtmacsApplet**): the applet to look for.</span>
<span class="sd">        * ``split`` (**QtmacsSplitter**): the splitter where to begin.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsSplitter**: the splitter that holds ``appletObj``</span>
<span class="sd">          or **None**.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Compile a list of all widgets in the splitter and check if</span>
        <span class="c"># one of them is the desired ``appletObj``.</span>
        <span class="n">widget_in_splitter</span> <span class="o">=</span> <span class="p">[</span><span class="n">split</span><span class="o">.</span><span class="n">widget</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">count</span><span class="p">())]</span>
        <span class="k">if</span> <span class="n">appletObj</span> <span class="ow">in</span> <span class="n">widget_in_splitter</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">split</span>

        <span class="c"># Retain only those widgets that are QtmacsSplitter instances.</span>
        <span class="n">split_in_splitter</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">widget_in_splitter</span>
            <span class="k">if</span> <span class="n">_</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span> <span class="o">==</span> <span class="s">&#39;__QtmacsLayoutSplitter__&#39;</span><span class="p">]</span>

        <span class="c"># Iterate over these splitters and by recursively calling ourselves.</span>
        <span class="k">for</span> <span class="n">nextSplit</span> <span class="ow">in</span> <span class="n">split_in_splitter</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteFindAppletInSplitter</span><span class="p">(</span><span class="n">appletObj</span><span class="p">,</span> <span class="n">nextSplit</span><span class="p">)</span>

            <span class="c"># If ``nextSplit`` holds the desired ``appletObj`` return</span>
            <span class="c"># a reference to it.</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>

        <span class="c"># The desired ``appletObj`` was not found in any of the</span>
        <span class="c"># splitter widgets inside the current splitter, or any of the</span>
        <span class="c"># children of these splitters.</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteSplitApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteSplitApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteSplitApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">applet</span><span class="p">:</span> <span class="p">(</span><span class="n">QtmacsApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">splitHoriz</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                       <span class="n">windowObj</span><span class="p">:</span> <span class="n">QtmacsWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reveal ``applet`` by splitting the space occupied by the</span>
<span class="sd">        current applet.</span>

<span class="sd">        If ``applet`` is already visible then the method does</span>
<span class="sd">        nothing. Furthermore, this method does not change the focus,</span>
<span class="sd">        ie. the currently active applet will remain active.</span>

<span class="sd">        If ``applet`` is **None** then the next invisible applet</span>
<span class="sd">        will be shown. If ``windowObj`` is **None** then the</span>
<span class="sd">        currently active window will be used.</span>

<span class="sd">        The ``applet`` parameter can either be an instance of</span>
<span class="sd">        ``QtmacsApplet`` or a string denoting an applet ID. In the</span>
<span class="sd">        latter case the ``qteGetAppletHandle`` method is used to fetch</span>
<span class="sd">        the respective applet instance.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``applet`` (**QtmacsApplet**, **str**): the applet to reveal.</span>
<span class="sd">        * ``splitHoriz`` (**bool**): whether to split horizontally</span>
<span class="sd">          or vertically.</span>
<span class="sd">        * ``windowObj`` (**QtmacsWindow**): the window in which to</span>
<span class="sd">          reveal ``applet``.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: if **True**, ``applet`` was revealed.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If ``newAppObj`` was specified by its ID (ie. a string) then</span>
        <span class="c"># fetch the associated ``QtmacsApplet`` instance. If</span>
        <span class="c"># ``newAppObj`` is already an instance of ``QtmacsApplet``</span>
        <span class="c"># then use it directly.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">applet</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">newAppObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">applet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newAppObj</span> <span class="o">=</span> <span class="n">applet</span>

        <span class="c"># Use the currently active window if none was specified.</span>
        <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">windowObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteActiveWindow</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Cannot determine the currently active window.&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="c"># Obtain the Qt constant that defines the horizontal or</span>
        <span class="c"># vertical split.</span>
        <span class="k">if</span> <span class="n">splitHoriz</span><span class="p">:</span>
            <span class="n">splitOrientation</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Horizontal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">splitOrientation</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Vertical</span>

        <span class="k">if</span> <span class="n">newAppObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># If no new applet was specified use the next available</span>
            <span class="c"># invisible applet.</span>
            <span class="n">newAppObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span><span class="n">skipVisible</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                           <span class="n">skipInvisible</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Do nothing if the new applet is already visible.</span>
            <span class="k">if</span> <span class="n">newAppObj</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># If we still have not found an applet then there are no</span>
        <span class="c"># invisible applets left to show. Therefore, splitting makes</span>
        <span class="c"># no sense.</span>
        <span class="k">if</span> <span class="n">newAppObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;All applets are already visible.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># If the root splitter is empty then add the new applet and</span>
        <span class="c"># return immediately.</span>
        <span class="k">if</span> <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="o">.</span><span class="n">qteAddWidget</span><span class="p">(</span><span class="n">newAppObj</span><span class="p">)</span>
            <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="o">.</span><span class="n">setOrientation</span><span class="p">(</span><span class="n">splitOrientation</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># If we got this far the root splitter contains at least one</span>
        <span class="c"># element.</span>
        <span class="c"># ------------------------------------------------------------</span>

        <span class="c"># Shorthand to last active applet in the current window. Query</span>
        <span class="c"># this applet with qteNextApplet method because</span>
        <span class="c"># self._qteActiveApplet may be a mini applet, and we are only</span>
        <span class="c"># interested in genuine applets.</span>
        <span class="n">curApp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span><span class="n">numSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">windowObj</span><span class="o">=</span><span class="n">windowObj</span><span class="p">)</span>

        <span class="c"># Get a reference to the splitter in which the currently</span>
        <span class="c"># active applet lives. This may be the root splitter, or one</span>
        <span class="c"># of its child splitters.</span>
        <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteFindAppletInSplitter</span><span class="p">(</span><span class="n">curApp</span><span class="p">,</span>
                                              <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">split</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Active applet &lt;b&gt;{}&lt;/b&gt; not in the layout.&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curApp</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># If &#39;curApp&#39; lives in the root splitter, and the root</span>
        <span class="c"># splitter contains only a single element, then simply add the</span>
        <span class="c"># new applet as the second element and return.</span>
        <span class="k">if</span> <span class="n">split</span> <span class="ow">is</span> <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="o">.</span><span class="n">qteAddWidget</span><span class="p">(</span><span class="n">newAppObj</span><span class="p">)</span>
                <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="o">.</span><span class="n">setOrientation</span><span class="p">(</span><span class="n">splitOrientation</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># If we got this far the splitter (root or not) contains two</span>
        <span class="c"># elements</span>
        <span class="c"># ------------------------------------------------------------</span>

        <span class="c"># Determine the index of the applet inside the splitter.</span>
        <span class="n">curAppIdx</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">curApp</span><span class="p">)</span>

        <span class="c"># Create a new splitter and move &#39;curApp&#39; and the previously</span>
        <span class="c"># invisible ``newAppObj`` into it. Then insert this new</span>
        <span class="c"># splitter at the position where the old applet was taken</span>
        <span class="c"># from. Note: the widgets are inserted with the</span>
        <span class="c"># ``qteAddWidget`` function (because they are Qtmacs applets)</span>
        <span class="c"># but the splitter is added with ``insertWidget`` and NOT with</span>
        <span class="c"># ``qteInsertWidget``. The reason is that the splitter is not</span>
        <span class="c"># a Qtmacs applet and therefore does not require the extra TLC</span>
        <span class="c"># for applets in terms of how and where to show them.</span>
        <span class="n">newSplit</span> <span class="o">=</span> <span class="n">QtmacsSplitter</span><span class="p">(</span><span class="n">splitOrientation</span><span class="p">,</span> <span class="n">windowObj</span><span class="p">)</span>
        <span class="n">curApp</span><span class="o">.</span><span class="n">setParent</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">newSplit</span><span class="o">.</span><span class="n">qteAddWidget</span><span class="p">(</span><span class="n">curApp</span><span class="p">)</span>
        <span class="n">newSplit</span><span class="o">.</span><span class="n">qteAddWidget</span><span class="p">(</span><span class="n">newAppObj</span><span class="p">)</span>
        <span class="n">split</span><span class="o">.</span><span class="n">insertWidget</span><span class="p">(</span><span class="n">curAppIdx</span><span class="p">,</span> <span class="n">newSplit</span><span class="p">)</span>

        <span class="c"># Ensure that the applets inside the new splitter share half</span>
        <span class="c"># the space. If this is impossible then the Qt layout engine</span>
        <span class="c"># will take care of it.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">newSplit</span><span class="o">.</span><span class="n">sizes</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">newSplit</span><span class="o">.</span><span class="n">setSizes</span><span class="p">([</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteReplaceAppletInLayout"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteReplaceAppletInLayout">[docs]</a>    <span class="k">def</span> <span class="nf">qteReplaceAppletInLayout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newApplet</span><span class="p">:</span> <span class="p">(</span><span class="n">QtmacsApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
                                 <span class="n">oldApplet</span><span class="p">:</span> <span class="p">(</span><span class="n">QtmacsApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                 <span class="n">windowObj</span><span class="p">:</span> <span class="n">QtmacsWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace ``oldApplet`` with ``newApplet`` in the window layout.</span>

<span class="sd">        If ``oldApplet`` is **None** then the currently active applet</span>
<span class="sd">        will be replaced. If ``windowObj`` is **None** then the</span>
<span class="sd">        currently active window is used.</span>

<span class="sd">        The ``oldApplet`` and ``newApplet`` parameters can either be</span>
<span class="sd">        instances of ``QtmacsApplet`` or strings denoting the applet</span>
<span class="sd">        IDs. In the latter case the ``qteGetAppletHandle`` method is</span>
<span class="sd">        used to fetch the respective applet instances.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``newApplet`` (**QtmacsApplet**, **str**): applet to add.</span>
<span class="sd">        * ``oldApplet`` (**QtmacsApplet**, **str**): applet to replace.</span>
<span class="sd">        * ``windowObj`` (**QtmacsWindow**): the window in which to operate.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If ``oldAppObj`` was specified by its ID (ie. a string) then</span>
        <span class="c"># fetch the associated ``QtmacsApplet`` instance. If</span>
        <span class="c"># ``oldAppObj`` is already an instance of ``QtmacsApplet``</span>
        <span class="c"># then use it directly.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oldApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">oldAppObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">oldApplet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">oldAppObj</span> <span class="o">=</span> <span class="n">oldApplet</span>

        <span class="c"># If ``newAppObj`` was specified by its ID (ie. a string) then</span>
        <span class="c"># fetch the associated ``QtmacsApplet`` instance. If</span>
        <span class="c"># ``newAppObj`` is already an instance of ``QtmacsApplet``</span>
        <span class="c"># then use it directly.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">newAppObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">newApplet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newAppObj</span> <span class="o">=</span> <span class="n">newApplet</span>

        <span class="c"># Use the currently active window if none was specified.</span>
        <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">windowObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteActiveWindow</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">windowObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Cannot determine the currently active window.&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="c"># If the main splitter contains no applet then just add newAppObj.</span>
        <span class="k">if</span> <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="o">.</span><span class="n">qteAddWidget</span><span class="p">(</span><span class="n">newAppObj</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># If no oldAppObj was specified use the currently active one</span>
        <span class="c"># instead. Do not use qteActiveApplet to determine it, though,</span>
        <span class="c"># because it may point to a mini buffer. If it is, then we</span>
        <span class="c"># need the last active Qtmacs applet. In either case, the</span>
        <span class="c"># qteNextApplet method will take care of these distinctions.</span>
        <span class="k">if</span> <span class="n">oldAppObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">oldAppObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span><span class="n">numSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">windowObj</span><span class="o">=</span><span class="n">windowObj</span><span class="p">)</span>

        <span class="c"># Sanity check: the applet to replace must exist.</span>
        <span class="k">if</span> <span class="n">oldAppObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Applet to replace does not exist.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># Sanity check: do nothing if the old- and new applet are the</span>
        <span class="c"># same.</span>
        <span class="k">if</span> <span class="n">newAppObj</span> <span class="ow">is</span> <span class="n">oldAppObj</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># Sanity check: do nothing if both applets are already</span>
        <span class="c"># visible.</span>
        <span class="k">if</span> <span class="n">oldAppObj</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">()</span> <span class="ow">and</span> <span class="n">newAppObj</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c"># Search for the splitter that contains &#39;oldAppObj&#39;.</span>
        <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteFindAppletInSplitter</span><span class="p">(</span><span class="n">oldAppObj</span><span class="p">,</span>
                                              <span class="n">windowObj</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">split</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Applet &lt;b&gt;{}&lt;/b&gt; not replaced because it is not&#39;</span>
                   <span class="s">&#39;in the layout.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">oldAppObj</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># Determine the position of oldAppObj inside the splitter.</span>
        <span class="n">oldAppIdx</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">oldAppObj</span><span class="p">)</span>

        <span class="c"># Replace oldAppObj with newAppObj. To do so, first insert</span>
        <span class="c"># newAppObj into the splitter at the position of oldAppObj and</span>
        <span class="c"># then remove oldAppObj by re-parenting it and making it</span>
        <span class="c"># invisible.</span>
        <span class="n">split</span><span class="o">.</span><span class="n">qteInsertWidget</span><span class="p">(</span><span class="n">oldAppIdx</span><span class="p">,</span> <span class="n">newAppObj</span><span class="p">)</span>
        <span class="n">oldAppObj</span><span class="o">.</span><span class="n">hide</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteRemoveAppletFromLayout"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteRemoveAppletFromLayout">[docs]</a>    <span class="k">def</span> <span class="nf">qteRemoveAppletFromLayout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">applet</span><span class="p">:</span> <span class="p">(</span><span class="n">QtmacsApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove ``applet`` from the window layout.</span>

<span class="sd">        This method removes ``applet`` and implicitly deletes</span>
<span class="sd">        obsolete (ie. half-full) splitters in the process. If</span>
<span class="sd">        ``applet`` is the only visible applet in the layout then it</span>
<span class="sd">        will be replaced with the first invisible applet. If no</span>
<span class="sd">        invisible applets are left then the method does nothing.</span>

<span class="sd">        The ``applet`` parameter can either be an instance of</span>
<span class="sd">        ``QtmacsApplet`` or a string denoting an applet ID. In the</span>
<span class="sd">        latter case the ``qteGetAppletHandle`` method is used to fetch</span>
<span class="sd">        the respective applet instance.</span>

<span class="sd">        If ``applet`` does not refer to an existing applet then</span>
<span class="sd">        nothing happens.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``applet`` (**QtmacsApplet**, **str**): the applet to remove</span>
<span class="sd">          from the layout.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If ``applet`` was specified by its ID (ie. a string) then</span>
        <span class="c"># fetch the associated ``QtmacsApplet`` instance. If</span>
        <span class="c"># ``applet`` is already an instance of ``QtmacsApplet`` then</span>
        <span class="c"># use it directly.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">applet</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">appletObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">applet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">appletObj</span> <span class="o">=</span> <span class="n">applet</span>

        <span class="c"># Return immediately if the applet does not exist in any splitter.</span>
        <span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">:</span>
            <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteFindAppletInSplitter</span><span class="p">(</span>
                <span class="n">appletObj</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">split</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">split</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># If the applet lives in the main splitter and is the only</span>
        <span class="c"># widget there it must be replaced with another applet. This</span>
        <span class="c"># case needs to be handled separately from the other options</span>
        <span class="c"># because every other splitter will always contain exactly two</span>
        <span class="c"># items (ie. two applets, two splitters, or one of each).</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">split</span> <span class="ow">is</span> <span class="n">window</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># Remove the existing applet object from the splitter and</span>
            <span class="c"># hide it.</span>
            <span class="n">split</span><span class="o">.</span><span class="n">widget</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hide</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># Get the next available applet to focus on. Try to find a</span>
            <span class="c"># visible applet in the current window, and if none exists</span>
            <span class="c"># then pick the first invisible one. If there is neither</span>
            <span class="c"># a visible nor an invisible applet left then do nothing.</span>
            <span class="n">nextApp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span><span class="n">windowObj</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nextApp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">nextApp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span><span class="n">skipInvisible</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                             <span class="n">skipVisible</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nextApp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span>

            <span class="c"># Ok, we found an applet to show.</span>
            <span class="n">split</span><span class="o">.</span><span class="n">qteAddWidget</span><span class="p">(</span><span class="n">nextApp</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># ------------------------------------------------------------</span>
        <span class="c"># If we got until here we know that the splitter (root or not)</span>
        <span class="c"># contains (at least) two elements. Note: if it contains more</span>
        <span class="c"># than two elements then there is a bug somewhere.</span>
        <span class="c"># ------------------------------------------------------------</span>

        <span class="c"># Find the index of the object inside the splitter.</span>
        <span class="n">appletIdx</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">appletObj</span><span class="p">)</span>

        <span class="c"># Detach the applet from the splitter and make it invisible.</span>
        <span class="n">appletObj</span><span class="o">.</span><span class="n">hide</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Verify that really only one additional element is left in</span>
        <span class="c"># the splitter. If not, then something is wrong.</span>
        <span class="k">if</span> <span class="n">split</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Splitter has &lt;b&gt;{}&lt;/b&gt; elements left instead of&#39;</span>
                   <span class="s">&#39; exactly one.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">count</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c"># Get a reference to the other widget in the splitter (either</span>
        <span class="c"># a QtmacsSplitter or a QtmacsApplet).</span>
        <span class="n">otherWidget</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="n">widget</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># Is the other widget another splitter?</span>
        <span class="k">if</span> <span class="n">otherWidget</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span> <span class="o">==</span> <span class="s">&#39;__QtmacsLayoutSplitter__&#39;</span><span class="p">:</span>
            <span class="c"># Yes, ``otherWidget`` is a QtmacsSplitter object,</span>
            <span class="c"># therefore shift all its widgets over to the current</span>
            <span class="c"># splitter.</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">otherWidget</span><span class="o">.</span><span class="n">count</span><span class="p">()):</span>
                <span class="c"># Get the next widget from that splitter. Note that we</span>
                <span class="c"># always pick the widget at the 0&#39;th position because</span>
                <span class="c"># the splitter will re-index the remaining widgets</span>
                <span class="c"># after each removal.</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">otherWidget</span><span class="o">.</span><span class="n">widget</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">appletIdx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">split</span><span class="o">.</span><span class="n">qteAddWidget</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">split</span><span class="o">.</span><span class="n">qteInsertWidget</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">ii</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

            <span class="c"># Delete the child splitter.</span>
            <span class="n">otherWidget</span><span class="o">.</span><span class="n">setParent</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">otherWidget</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># No, ``otherWidget`` is a QtmacsApplet, therefore move it</span>
            <span class="c"># to the parent splitter and delete the current one,</span>
            <span class="c"># unless &#39;split&#39; is the root splitter in which case</span>
            <span class="c"># nothing happens.</span>
            <span class="k">if</span> <span class="n">split</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">window</span><span class="o">.</span><span class="n">qteAppletSplitter</span><span class="p">:</span>
                <span class="n">otherWidget</span><span class="o">.</span><span class="n">qteReparent</span><span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="n">split</span><span class="o">.</span><span class="n">setParent</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="n">split</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteKillApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteKillApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteKillApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appletID</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroy the applet with ID ``appletID``.</span>

<span class="sd">        This method removes ``appletID`` from Qtmacs permanently - no</span>
<span class="sd">        questions asked. It is the responsibility of the (macro)</span>
<span class="sd">        programmer to use it responsibly.</span>

<span class="sd">        If the applet was visible then the method also takes care of</span>
<span class="sd">        replacing with the next invisible applet, if one is available.</span>

<span class="sd">        If ``appletID`` does not refer to a valid applet then nothing</span>
<span class="sd">        happens.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``appletID`` (**str**): name of applet to be destroyed.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Compile list of all applet IDs.</span>
        <span class="n">ID_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">appletID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ID_list</span><span class="p">:</span>
            <span class="c"># Do nothing if the applet does not exist.</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Get a reference to the actual applet object based on the</span>
            <span class="c"># name.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ID_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">appletID</span><span class="p">)</span>
            <span class="n">appObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c"># Mini applets are killed with a special method.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteIsMiniApplet</span><span class="p">(</span><span class="n">appObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteKillMiniApplet</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="c"># Inform the applet that it is about to be killed.</span>
        <span class="n">appObj</span><span class="o">.</span><span class="n">qteToBeKilled</span><span class="p">()</span>

        <span class="c"># Determine the window of the applet.</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">appObj</span><span class="o">.</span><span class="n">qteParentWindow</span><span class="p">()</span>

        <span class="c"># Get the previous invisible applet (*may* come in handy a few</span>
        <span class="c"># lines below).</span>
        <span class="n">newApplet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteNextApplet</span><span class="p">(</span><span class="n">numSkip</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">skipInvisible</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                       <span class="n">skipVisible</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># If there is no invisible applet available, or the only available</span>
        <span class="c"># applet is the one to be killed, then set newApplet to None.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newApplet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">newApplet</span> <span class="ow">is</span> <span class="n">appObj</span><span class="p">):</span>
            <span class="n">newApplet</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteReplaceAppletInLayout</span><span class="p">(</span><span class="n">newApplet</span><span class="p">,</span> <span class="n">appObj</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>

        <span class="c"># Ensure that _qteActiveApplet does not point to the applet</span>
        <span class="c"># to be killed as it will otherwise result in a dangling</span>
        <span class="c"># pointer.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="ow">is</span> <span class="n">appObj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="n">newApplet</span>

        <span class="c"># Remove the applet object from the applet list.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Kill applet: &lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">appletID</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">appObj</span><span class="p">)</span>

        <span class="c"># Close the applet and schedule it for destruction. Explicitly</span>
        <span class="c"># call the sip.delete() method to ensure that all signals are</span>
        <span class="c"># *immediately* disconnected, as otherwise there is a good</span>
        <span class="c"># chance that Qtmacs segfaults if Python/Qt thinks the slots</span>
        <span class="c"># are still connected when really the object does not exist</span>
        <span class="c"># anymore.</span>
        <span class="n">appObj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">sip</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">appObj</span><span class="p">)</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteRunHook"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteRunHook">[docs]</a>    <span class="k">def</span> <span class="nf">qteRunHook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hookName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">msgObj</span><span class="p">:</span> <span class="n">QtmacsMessage</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trigger the hook named ``hookName`` and pass on ``msgObj``.</span>

<span class="sd">        This will call all slots associated with ``hookName`` but</span>
<span class="sd">        without calling the event loop in between. Therefore, if</span>
<span class="sd">        one slots changes the state of the GUI, every subsequent slot</span>
<span class="sd">        may have difficulties determining the actual state of the GUI</span>
<span class="sd">        using Qt accessor functions. It is thus usually a good idea</span>
<span class="sd">        to either avoid manipulating the GUI directly, or call macros</span>
<span class="sd">        because Qtmacs will always run the event loop in between any</span>
<span class="sd">        two macros.</span>

<span class="sd">        .. note: the slots are executed in the order in which they</span>
<span class="sd">          were registered via ``qteConnectHook``, but there is no</span>
<span class="sd">          guarantee that this is really so. However, it is guaranteed</span>
<span class="sd">          that all slots will be triggered, even if some raise an error</span>
<span class="sd">          during the execution.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``hookName`` (**str**): the name of the hook to trigger.</span>
<span class="sd">        * ``msgObj`` (**QtmacsMessage**): data passed to the function.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Shorthand.</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryHooks</span>

        <span class="c"># Do nothing if there are not recipients for the hook.</span>
        <span class="k">if</span> <span class="n">hookName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reg</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># Create an empty ``QtmacsMessage`` object if none was provided.</span>
        <span class="k">if</span> <span class="n">msgObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msgObj</span> <span class="o">=</span> <span class="n">QtmacsMessage</span><span class="p">()</span>

        <span class="c"># Add information about the hook that will deliver ``msgObj``.</span>
        <span class="n">msgObj</span><span class="o">.</span><span class="n">setHookName</span><span class="p">(</span><span class="n">hookName</span><span class="p">)</span>

        <span class="c"># Try to call each slot. Intercept any errors but ensure that</span>
        <span class="c"># really all slots are called, irrespective of how many of them</span>
        <span class="c"># raise an error during execution.</span>
        <span class="k">for</span> <span class="n">fun</span> <span class="ow">in</span> <span class="n">reg</span><span class="p">[</span><span class="n">hookName</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fun</span><span class="p">(</span><span class="n">msgObj</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c"># Format the error message.</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&lt;b&gt;{}&lt;/b&gt;-hook function &lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">hookName</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">fun</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot; did not execute properly.&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">QtmacsArgumentError</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;&lt;br/&gt;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

                <span class="c"># Log the error.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteConnectHook"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteConnectHook">[docs]</a>    <span class="k">def</span> <span class="nf">qteConnectHook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hookName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">slot</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect the method or function ``slot`` to ``hookName``.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``hookName`` (**str**): name of the hook.</span>
<span class="sd">        * ``slot`` (**function**, **method**): the routine to execute</span>
<span class="sd">          when the hook triggers.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Shorthand.</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryHooks</span>
        <span class="k">if</span> <span class="n">hookName</span> <span class="ow">in</span> <span class="n">reg</span><span class="p">:</span>
            <span class="n">reg</span><span class="p">[</span><span class="n">hookName</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slot</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reg</span><span class="p">[</span><span class="n">hookName</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">slot</span><span class="p">]</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteDisconnectHook"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteDisconnectHook">[docs]</a>    <span class="k">def</span> <span class="nf">qteDisconnectHook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hookName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                          <span class="n">slot</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnect ``slot`` from ``hookName``.</span>

<span class="sd">        If ``hookName`` does not exist, or ``slot`` is not connected</span>
<span class="sd">        to ``hookName`` then return **False**, otherwise disassociate</span>
<span class="sd">        ``slot`` with ``hookName`` and return **True**.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``hookName`` (**str**): name of the hook.</span>
<span class="sd">        * ``slot`` (**function**, **method**): the routine to</span>
<span class="sd">          execute when the hook triggers.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: **True** if ``slot`` was disconnected from ``hookName``,</span>
<span class="sd">          and **False** in all other cases.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Shorthand.</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryHooks</span>

        <span class="c"># Return immediately if no hook with that name exists.</span>
        <span class="k">if</span> <span class="n">hookName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reg</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;There is no hook called &lt;b&gt;{}&lt;/b&gt;.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hookName</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Return immediately if the ``slot`` is not connected to the hook.</span>
        <span class="k">if</span> <span class="n">slot</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reg</span><span class="p">[</span><span class="n">hookName</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Slot &lt;b&gt;{}&lt;/b&gt; is not connected to hook &lt;b&gt;{}&lt;/b&gt;.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">slot</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">hookName</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Remove ``slot`` from the list.</span>
        <span class="n">reg</span><span class="p">[</span><span class="n">hookName</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">slot</span><span class="p">)</span>

        <span class="c"># If the list is now empty, then remove it altogether.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="n">hookName</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">reg</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">hookName</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteImportModule"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteImportModule">[docs]</a>    <span class="k">def</span> <span class="nf">qteImportModule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import ``fileName`` at run-time.</span>

<span class="sd">        If ``fileName`` has no path prefix then it must be in the</span>
<span class="sd">        standard Python module path. Relative path names are possible.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``fileName`` (**str**): file name (with full path) of module</span>
<span class="sd">          to import.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **module**: the imported Python module, or **None** if an</span>
<span class="sd">            error occurred.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Split the absolute file name into the path- and file name.</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c"># If the file name has a path prefix then search there, other</span>
        <span class="c"># search the default paths for Python.</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>

        <span class="c"># Try to locate the module.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fp</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Could not find module &lt;b&gt;{}&lt;/b&gt;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Try to import the module.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mod</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Could not import module &lt;b&gt;{}&lt;/b&gt;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># According to the imp documentation the file pointer</span>
            <span class="c"># should always be closed explicitly.</span>
            <span class="k">if</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteMacroNameMangling"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteMacroNameMangling">[docs]</a>    <span class="k">def</span> <span class="nf">qteMacroNameMangling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">macroCls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the class name of a macro class to macro name.</span>

<span class="sd">        The name mangling inserts a &#39;-&#39; character after every capital</span>
<span class="sd">        letter and then lowers the entire string.</span>

<span class="sd">        Example: if the class name of ``macroCls`` is &#39;ThisIsAMacro&#39;</span>
<span class="sd">        then this method will return &#39;this-is-a-macro&#39;, ie. every</span>
<span class="sd">        capital letter (except the first) will be prefixed with a</span>
<span class="sd">        hyphen and changed to lower case.</span>

<span class="sd">        The method returns the name mangled macro name or **None**</span>
<span class="sd">        if an error occurred.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``macroCls`` (**QtmacsMacro**): ``QtmacsMacro``- or derived</span>
<span class="sd">          class (not an instance!)</span>

<span class="sd">        |Returns|</span>

<span class="sd">        **str**: the name mangled string or **None** if an error occurred.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Replace camel bump as hyphenated lower case string.</span>
        <span class="n">macroName</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">r&quot;([A-Z])&quot;</span><span class="p">,</span> <span class="s">r&#39;-\1&#39;</span><span class="p">,</span> <span class="n">macroCls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="c"># If the first character of the class name was a</span>
        <span class="c"># capital letter (likely) then the above substitution would have</span>
        <span class="c"># resulted in a leading hyphen. Remove it.</span>
        <span class="k">if</span> <span class="n">macroName</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">macroName</span> <span class="o">=</span> <span class="n">macroName</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c"># Return the lower case string.</span>
        <span class="k">return</span> <span class="n">macroName</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteRegisterMacro"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteRegisterMacro">[docs]</a>    <span class="k">def</span> <span class="nf">qteRegisterMacro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">macroCls</span><span class="p">,</span> <span class="n">replaceMacro</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                         <span class="n">macroName</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a macro.</span>

<span class="sd">        If ``macroName`` is **None** then its named is deduced from</span>
<span class="sd">        its class name (see ``qteMacroNameMangling`` for details).</span>

<span class="sd">        Multiple macros with the same name can co-exist as long as</span>
<span class="sd">        their applet- and widget signatures, as reported by the</span>
<span class="sd">        ``qteAppletSignature`` and ``qteWidgetSignature`` methods,</span>
<span class="sd">        differ. If ``macroCls`` has the same name and signatures as an</span>
<span class="sd">        already registered macro then the ``replaceMacro`` flag</span>
<span class="sd">        decides:</span>

<span class="sd">        * **True**: the existing macro will be replaced for all</span>
<span class="sd">          applet- and widget signatures specified by the new macro</span>
<span class="sd">          ``macroCls``.</span>
<span class="sd">        * **False**: the ``macroCls`` will not be registered.</span>

<span class="sd">        The method returns **None** if an error occurred (eg. the</span>
<span class="sd">        macro constructor is faulty), or the macro name as a</span>
<span class="sd">        string. If a macro was already registered and not replaced</span>
<span class="sd">        (ie. ``replaceMacro``) then the macro name is returned</span>
<span class="sd">        nonetheless.</span>

<span class="sd">        .. note:: if an existing macro is replaced the old macro</span>
<span class="sd">           is not deleted (it probably should be, though).</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``macroCls`` (**QtmacsMacro**): QtmacsMacro or derived</span>
<span class="sd">          (not type checked!)</span>
<span class="sd">        * ``replaceMacro`` (**bool**): whether or not to replace</span>
<span class="sd">          an existing macro.</span>
<span class="sd">        * ``macroName`` (**str**): the name under which the macro</span>
<span class="sd">          should be registered.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        **str**: the name of the just registered macro, or **None** if</span>
<span class="sd">          that failed.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check type of input arguments.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">macroCls</span><span class="p">,</span> <span class="n">QtmacsMacro</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;macroCls&#39;</span><span class="p">,</span> <span class="s">&#39;class QtmacsMacro&#39;</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">raise</span> <span class="n">QtmacsArgumentError</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c"># Try to instantiate the macro class.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">macroObj</span> <span class="o">=</span> <span class="n">macroCls</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;The macro &lt;b&gt;{}&lt;/b&gt; has a faulty constructor.&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroCls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># The three options to determine the macro name, in order of</span>
        <span class="c"># precedence, are: passed to this function, specified in the</span>
        <span class="c"># macro constructor, name mangled.</span>
        <span class="k">if</span> <span class="n">macroName</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># No macro name was passed to the function.</span>
            <span class="k">if</span> <span class="n">macroObj</span><span class="o">.</span><span class="n">qteMacroName</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># The macro has already named itself.</span>
                <span class="n">macroName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteMacroNameMangling</span><span class="p">(</span><span class="n">macroCls</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># The macro name is inferred from the class name.</span>
                <span class="n">macroName</span> <span class="o">=</span> <span class="n">macroObj</span><span class="o">.</span><span class="n">qteMacroName</span><span class="p">()</span>

        <span class="c"># Let the macro know under which name it is known inside Qtmacs.</span>
        <span class="n">macroObj</span><span class="o">.</span><span class="n">_qteMacroName</span> <span class="o">=</span> <span class="n">macroName</span>

        <span class="c"># Ensure the macro has applet signatures.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">macroObj</span><span class="o">.</span><span class="n">qteAppletSignature</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Macro &lt;b&gt;{}&lt;/b&gt; has no applet signatures.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroName</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Ensure the macro has widget signatures.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">macroObj</span><span class="o">.</span><span class="n">qteWidgetSignature</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Macro &lt;b&gt;{}&lt;/b&gt; has no widget signatures.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroName</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Flag to indicate that at least one new macro type was</span>
        <span class="c"># registered.</span>
        <span class="n">anyRegistered</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Iterate over all applet signatures.</span>
        <span class="k">for</span> <span class="n">app_sig</span> <span class="ow">in</span> <span class="n">macroObj</span><span class="o">.</span><span class="n">qteAppletSignature</span><span class="p">():</span>
            <span class="c"># Iterate over all widget signatures.</span>
            <span class="k">for</span> <span class="n">wid_sig</span> <span class="ow">in</span> <span class="n">macroObj</span><span class="o">.</span><span class="n">qteWidgetSignature</span><span class="p">():</span>
                <span class="c"># Infer the macro name from the class name of the</span>
                <span class="c"># passed macro object.</span>
                <span class="n">macroNameInternal</span> <span class="o">=</span> <span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">app_sig</span><span class="p">,</span> <span class="n">wid_sig</span><span class="p">)</span>

                <span class="c"># If a macro with this name already exists then either</span>
                <span class="c"># replace it, or skip the registration process for the</span>
                <span class="c"># new one.</span>
                <span class="k">if</span> <span class="n">macroNameInternal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">replaceMacro</span><span class="p">:</span>
                        <span class="c"># Remove existing macro.</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">macroNameInternal</span><span class="p">)</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Replacing existing macro &lt;b&gt;{}&lt;/b&gt; with new {}.&#39;</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroNameInternal</span><span class="p">,</span> <span class="n">macroObj</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">deleteLater</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Macro &lt;b&gt;{}&lt;/b&gt; already exists (not replaced).&#39;</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroNameInternal</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="c"># Macro was not registered for this widget</span>
                        <span class="c"># signature.</span>
                        <span class="k">continue</span>

                <span class="c"># Add macro object to the registry.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="p">[</span><span class="n">macroNameInternal</span><span class="p">]</span> <span class="o">=</span> <span class="n">macroObj</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Macro &lt;b&gt;{}&lt;/b&gt; successfully registered.&#39;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroNameInternal</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">anyRegistered</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Return the name of the macro, irrespective of whether or not</span>
        <span class="c"># it is a newly created macro, or if the old macro was kept</span>
        <span class="c"># (in case of a name conflict).</span>
        <span class="k">return</span> <span class="n">macroName</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteIsMacroRegistered"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteIsMacroRegistered">[docs]</a>    <span class="k">def</span> <span class="nf">qteIsMacroRegistered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">macroName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                             <span class="n">widgetObj</span><span class="p">:</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return **True** if a macro with name ``macroName`` exists.</span>

<span class="sd">        If ``widgetObj`` is **None** then only the macro name is</span>
<span class="sd">        matched. Otherwise, only macros that are compatible with</span>
<span class="sd">        ``widgetObj`` are returned.</span>


<span class="sd">        |Args|</span>

<span class="sd">        * ``macroName`` (**str**): name of macro.</span>
<span class="sd">        * ``widgetObj`` (**QWidget**): widget with which the macro</span>
<span class="sd">          must be compatible.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: whether or not a compatible macro exists.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">widgetObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Ignore the applet- and widget signature and simply check</span>
            <span class="c"># if a macro with the desired name exists.</span>
            <span class="n">macroList</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span>
                         <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">macroName</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">macroList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Take the applet- and widget signature into account.</span>
            <span class="n">macroObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetMacroObject</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">macroObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteGetMacroObject"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteGetMacroObject">[docs]</a>    <span class="k">def</span> <span class="nf">qteGetMacroObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">macroName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">:</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return macro that is name- and signature compatible with</span>
<span class="sd">        ``macroName`` and ``widgetObj``.</span>

<span class="sd">        The method considers all macros with name ``macroName`` and</span>
<span class="sd">        returns the one that matches &#39;best&#39;. To determine this best</span>
<span class="sd">        match, the applet-and widget signatures of the macro are</span>
<span class="sd">        compared to those of ``widgetObj`` and picked in the following</span>
<span class="sd">        order:</span>

<span class="sd">        1. Applet- and widget signature of both match.</span>
<span class="sd">        2. Widget signature matches, applet signature in macro is &quot;*&quot;</span>
<span class="sd">        3. Applet signature matches, widget signature in macro is &quot;*&quot;</span>
<span class="sd">        4. Macro reports &quot;*&quot; for both its applet- and widget signature.</span>

<span class="sd">        If the macro does not fit any of these four criteria, then no</span>
<span class="sd">        compatible macro is available and the method returns **None**.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``macroName`` (**str**): name of macro.</span>
<span class="sd">        * ``widgetObj`` (**QWidget**): widget for which a compatible</span>
<span class="sd">          macro is sought.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsMacro**: best matching macro, or **None**.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Determine the applet- and widget signature. This is trivial</span>
        <span class="c"># if the widget was registered with Qtmacs because its</span>
        <span class="c"># &#39;_qteAdmin&#39; attribute will provide this information. If, on</span>
        <span class="c"># the other hand, the widget was not registered with Qtmacs</span>
        <span class="c"># then it has no signature, yet its parent applet must because</span>
        <span class="c"># every applet has one. The only exception when the applet</span>
        <span class="c"># signature is therefore when there are no applets to begin</span>
        <span class="c"># with, ie. the the window is empty.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">,</span> <span class="s">&#39;_qteAdmin&#39;</span><span class="p">):</span>
            <span class="n">app_signature</span> <span class="o">=</span> <span class="n">widgetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">appletSignature</span>
            <span class="n">wid_signature</span> <span class="o">=</span> <span class="n">widgetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetSignature</span>

            <span class="c"># Return immediately if the applet signature is None</span>
            <span class="c"># (should be impossible).</span>
            <span class="k">if</span> <span class="n">app_signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Applet has no signature.&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wid_signature</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">app</span> <span class="o">=</span> <span class="n">qteGetAppletFromWidget</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">app_signature</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">app_signature</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">appletSignature</span>

        <span class="c"># Find all macros with name &#39;macroName&#39;. This will produce a list of</span>
        <span class="c"># tuples with entries (macroName, app_sig, wid_sig).</span>
        <span class="n">name_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span> <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">macroName</span><span class="p">]</span>

        <span class="c"># Find all macros with a compatible applet signature. This is</span>
        <span class="c"># produce another list of tuples with the same format as</span>
        <span class="c"># the name_match list (see above).</span>
        <span class="n">app_sig_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">name_match</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">app_signature</span><span class="p">,</span> <span class="s">&#39;*&#39;</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">wid_signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wid_sig_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">app_sig_match</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Find all macros with a compatible widget signature. This is</span>
            <span class="c"># a list of tuples, each tuple consisting of (macroName,</span>
            <span class="c"># app_sig, wid_sig).</span>
            <span class="n">wid_sig_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">app_sig_match</span>
                             <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wid_signature</span><span class="p">,</span> <span class="s">&#39;*&#39;</span><span class="p">)]</span>

        <span class="c"># Pick a macro.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wid_sig_match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># No macro is compatible with either the applet- or widget</span>
            <span class="c"># signature.</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">wid_sig_match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">wid_sig_match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Exactly one macro is compatible with either the applet-</span>
            <span class="c"># or widget signature.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="p">[</span><span class="n">match</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Found multiple matches. For any given macro &#39;name&#39;,</span>
            <span class="c"># applet signature &#39;app&#39;, and widget signature &#39;wid&#39; there</span>
            <span class="c"># can be at most four macros in the list: *:*:name,</span>
            <span class="c"># wid:*:name, *:app:name, and wid:app:name.</span>

            <span class="c"># See if there is a macro for which both the applet and</span>
            <span class="c"># widget signature match.</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">match</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">wid_sig_match</span> <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;*&#39;</span><span class="p">)</span>
                   <span class="ow">and</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;*&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="p">[</span><span class="n">match</span><span class="p">]</span>

            <span class="c"># See if there is a macro with a matching widget signature.</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">match</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">wid_sig_match</span> <span class="k">if</span> <span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;*&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="p">[</span><span class="n">match</span><span class="p">]</span>

            <span class="c"># See if there is a macro with a matching applet signature.</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">match</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">wid_sig_match</span> <span class="k">if</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;*&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="p">[</span><span class="n">match</span><span class="p">]</span>

            <span class="c"># At this point only one possibility is left, namely a</span>
            <span class="c"># generic macro that is applicable to arbitrary applets</span>
            <span class="c"># and widgets, eg. NextApplet.</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">match</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">wid_sig_match</span> <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">)</span>
                   <span class="ow">and</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="p">[</span><span class="n">match</span><span class="p">]</span>

            <span class="c"># This should be impossible.</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;No compatible macro found - should be impossible.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteGetAllMacroNames"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteGetAllMacroNames">[docs]</a>    <span class="k">def</span> <span class="nf">qteGetAllMacroNames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">:</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all macro names known to Qtmacs as a list.</span>

<span class="sd">        If ``widgetObj`` is **None** then the names of all registered</span>
<span class="sd">        macros are returned as a tuple. Otherwise, only those macro</span>
<span class="sd">        compatible with ``widgetObj`` are returned. See</span>
<span class="sd">        ``qteGetMacroObject`` for the definition of a compatible</span>
<span class="sd">        macro.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``widgetObj`` (**QWidget**): widget with which the macros</span>
<span class="sd">          must be compatible.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **tuple**: tuple of macro names.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The keys of qteRegistryMacros are (macroObj, app_sig,</span>
        <span class="c"># wid_sig) tuples. Get them, extract the macro names, and</span>
        <span class="c"># remove all duplicates.</span>
        <span class="n">macro_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryMacros</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">macro_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">macro_list</span><span class="p">]</span>
        <span class="n">macro_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">macro_list</span><span class="p">))</span>

        <span class="c"># If no widget object was supplied then omit the signature</span>
        <span class="c"># check and return the macro list verbatim.</span>
        <span class="k">if</span> <span class="n">widgetObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">macro_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Use qteGetMacroObject to compile a list of macros that</span>
            <span class="c"># are compatible with widgetObj. This list contains</span>
            <span class="c"># (macroObj, macroName, app_sig, wid_sig) tuples.</span>
            <span class="n">macro_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qteGetMacroObject</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">macroName</span> <span class="ow">in</span> <span class="n">macro_list</span><span class="p">]</span>

            <span class="c"># Remove all elements where macroObj=None. This is the</span>
            <span class="c"># case if no compatible macro with the specified name</span>
            <span class="c"># could be found for widgetObj.</span>
            <span class="n">macro_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">qteMacroName</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">macro_list</span>
                          <span class="k">if</span> <span class="n">_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">macro_list</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteBindKeyGlobal"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteBindKeyGlobal">[docs]</a>    <span class="k">def</span> <span class="nf">qteBindKeyGlobal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keysequence</span><span class="p">,</span> <span class="n">macroName</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Associate ``macroName`` with ``keysequence`` in all current</span>
<span class="sd">        applets.</span>

<span class="sd">        This method will bind ``macroName`` to ``keysequence`` in the</span>
<span class="sd">        global key map and **all** local key maps. This also applies</span>
<span class="sd">        for all applets (and their constituent widgets) yet to be</span>
<span class="sd">        instantiated because they will inherit a copy of the global</span>
<span class="sd">        keymap.</span>

<span class="sd">        .. note::  This binding is signature independent.</span>

<span class="sd">        If the ``macroName`` was not registered the method returns</span>
<span class="sd">        **False**.</span>

<span class="sd">        The ``keysequence`` can be specified either as a string (eg</span>
<span class="sd">        &#39;&lt;ctrl&gt;+x &lt;ctrl&gt;+f&#39;), or a list of tuples containing the</span>
<span class="sd">        constants from the ``QtCore.Qt`` name space</span>
<span class="sd">        (eg. [(ControlModifier, Key_X), (ControlModifier, Key_F)]), or</span>
<span class="sd">        as a ``QtmacsKeysequence`` object.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``keysequence`` (**str**, **list** of **tuples**,</span>
<span class="sd">          **QtmacsKeysequence**): key sequence to activate ``macroName``</span>
<span class="sd">          for specified ``widgetSignature``.</span>
<span class="sd">        * ``macroName`` (**str**): name of macro to associate with</span>
<span class="sd">          ``keysequence``.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        **bool**: **True** if the binding was successful.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        * **QtmacsKeysequenceError** if the provided ``keysequence``</span>
<span class="sd">          could not be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Convert the key sequence into a QtmacsKeysequence object, or</span>
        <span class="c"># raise an QtmacsOtherError if the conversion is impossible.</span>
        <span class="n">keysequence</span> <span class="o">=</span> <span class="n">QtmacsKeysequence</span><span class="p">(</span><span class="n">keysequence</span><span class="p">)</span>

        <span class="c"># Sanity check: the macro must have been registered</span>
        <span class="c"># beforehand.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteIsMacroRegistered</span><span class="p">(</span><span class="n">macroName</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Cannot globally bind key to unknown macro &lt;b&gt;{}&lt;/b&gt;.&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroName</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Insert/overwrite the key sequence and associate it with the</span>
        <span class="c"># new macro.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteGlobalKeyMap</span><span class="o">.</span><span class="n">qteInsertKey</span><span class="p">(</span><span class="n">keysequence</span><span class="p">,</span> <span class="n">macroName</span><span class="p">)</span>

        <span class="c"># Now update the local key map of every applet. Note that</span>
        <span class="c"># globally bound macros apply to every applet (hence the loop</span>
        <span class="c"># below) and every widget therein (hence the &quot;*&quot; parameter for</span>
        <span class="c"># the widget signature).</span>
        <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteBindKeyApplet</span><span class="p">(</span><span class="n">keysequence</span><span class="p">,</span> <span class="n">macroName</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteBindKeyApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteBindKeyApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteBindKeyApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keysequence</span><span class="p">,</span> <span class="n">macroName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                         <span class="n">appletObj</span><span class="p">:</span> <span class="n">QtmacsApplet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bind ``macroName`` to all widgets in ``appletObj``.</span>

<span class="sd">        This method does not affect the key bindings of other applets,</span>
<span class="sd">        or other instances of the same applet.</span>

<span class="sd">        The ``keysequence`` can be specified either as a string (eg</span>
<span class="sd">        &#39;&lt;ctrl&gt;+x &lt;ctrl&gt;+f&#39;), or a list of tuples containing the</span>
<span class="sd">        constants from the ``QtCore.Qt`` name space</span>
<span class="sd">        (eg. [(ControlModifier, Key_X), (ControlModifier, Key_F)]), or</span>
<span class="sd">        as a ``QtmacsKeysequence`` object.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``keysequence`` (**str**, **list** of **tuples**,</span>
<span class="sd">          **QtmacsKeysequence**):</span>
<span class="sd">          key sequence to activate ``macroName`` for specified</span>
<span class="sd">          ``widgetSignature``.</span>
<span class="sd">        * ``macroName`` (**str**): the macro to associated with</span>
<span class="sd">          ``keysequence``.</span>
<span class="sd">        * ``appletObj`` (**QtmacsApplet**): only widgets in this</span>
<span class="sd">          applet are affected.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: whether or not at least one widget was</span>
<span class="sd">          successfully bound.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        * **QtmacsKeysequenceError** if the provided ``keysequence``</span>
<span class="sd">          could not be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Convert the key sequence into a QtmacsKeysequence object, or</span>
        <span class="c"># raise a QtmacsKeysequenceError if the conversion is</span>
        <span class="c"># impossible.</span>
        <span class="n">keysequence</span> <span class="o">=</span> <span class="n">QtmacsKeysequence</span><span class="p">(</span><span class="n">keysequence</span><span class="p">)</span>

        <span class="c"># Verify that Qtmacs knows a macro named &#39;macroName&#39;.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteIsMacroRegistered</span><span class="p">(</span><span class="n">macroName</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Cannot bind key because the macro &lt;b&gt;{}&lt;/b&gt; does&#39;</span>
                   <span class="s">&#39;not exist.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroName</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Bind the key also to the applet itself because it can</span>
        <span class="c"># receive keyboard events (eg. when it is empty).</span>
        <span class="n">appletObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyMap</span><span class="o">.</span><span class="n">qteInsertKey</span><span class="p">(</span><span class="n">keysequence</span><span class="p">,</span> <span class="n">macroName</span><span class="p">)</span>

        <span class="c"># Update the key map of every widget inside the applet.</span>
        <span class="k">for</span> <span class="n">wid</span> <span class="ow">in</span> <span class="n">appletObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteBindKeyWidget</span><span class="p">(</span><span class="n">keysequence</span><span class="p">,</span> <span class="n">macroName</span><span class="p">,</span> <span class="n">wid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteBindKeyWidget"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteBindKeyWidget">[docs]</a>    <span class="k">def</span> <span class="nf">qteBindKeyWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keysequence</span><span class="p">,</span> <span class="n">macroName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                         <span class="n">widgetObj</span><span class="p">:</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bind ``macroName`` to ``widgetObj`` and associate it with</span>
<span class="sd">        ``keysequence``.</span>

<span class="sd">        This method does not affect the key bindings of other applets</span>
<span class="sd">        and/or widgets and can be used to individualise the key</span>
<span class="sd">        bindings inside every applet instance and every widget inside</span>
<span class="sd">        that instance. Even multiple instances of the same applet type</span>
<span class="sd">        (eg. multiple text buffers) can all have individual key</span>
<span class="sd">        bindings.</span>

<span class="sd">        The ``keysequence`` can be specified either as a string (eg</span>
<span class="sd">        &#39;&lt;ctrl&gt;+x &lt;ctrl&gt;+f&#39;), or a list of tuples containing the</span>
<span class="sd">        constants from the ``QtCore.Qt`` name space</span>
<span class="sd">        (eg. [(ControlModifier, Key_X), (ControlModifier, Key_F)]), or</span>
<span class="sd">        as a ``QtmacsKeysequence`` object.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``keysequence`` (**str**, **list** of **tuples**,</span>
<span class="sd">          **QtmacsKeysequence**):</span>
<span class="sd">          key sequence to activate ``macroName`` for specified</span>
<span class="sd">          ``widgetSignature``.</span>
<span class="sd">        * ``macroName`` (**str**): the macro to associated with</span>
<span class="sd">          ``keysequence``.</span>
<span class="sd">        * ``widgetObj`` (**QWidget**): determines which widgets</span>
<span class="sd">          signature to use.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: whether or not at least one widget was</span>
<span class="sd">            successfully bound.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        * **QtmacsKeysequenceError** if the provided ``keysequence``</span>
<span class="sd">          could not be parsed.</span>
<span class="sd">        * **QtmacsOtherError** if ``widgetObj`` was not added with</span>
<span class="sd">          ``qteAddWidget``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Convert the key sequence into a QtmacsKeysequence object, or</span>
        <span class="c"># raise an QtmacsKeysequenceError if the conversion is</span>
        <span class="c"># impossible.</span>
        <span class="n">keysequence</span> <span class="o">=</span> <span class="n">QtmacsKeysequence</span><span class="p">(</span><span class="n">keysequence</span><span class="p">)</span>

        <span class="c"># Check type of input arguments.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">,</span> <span class="s">&#39;_qteAdmin&#39;</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&lt;widgetObj&gt; was probably not added with &lt;qteAddWidget&gt;&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; method because it lacks the &lt;_qteAdmin&gt; attribute.&#39;</span>
            <span class="k">raise</span> <span class="n">QtmacsOtherError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c"># Verify that Qtmacs knows a macro named &#39;macroName&#39;.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteIsMacroRegistered</span><span class="p">(</span><span class="n">macroName</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Cannot bind key to unknown macro &lt;b&gt;{}&lt;/b&gt;.&#39;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">macroName</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Associate &#39;keysequence&#39; with &#39;macroName&#39; for &#39;widgetObj&#39;.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">widgetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyMap</span><span class="o">.</span><span class="n">qteInsertKey</span><span class="p">(</span><span class="n">keysequence</span><span class="p">,</span> <span class="n">macroName</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Received an invalid macro object.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteUnbindKeyApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteUnbindKeyApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteUnbindKeyApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">applet</span><span class="p">:</span> <span class="p">(</span><span class="n">QtmacsApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">keysequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove ``keysequence`` bindings from all widgets inside ``applet``.</span>

<span class="sd">        This method does not affect the key bindings of other applets,</span>
<span class="sd">        or different instances of the same applet.</span>

<span class="sd">        The ``keysequence`` can be specified either as a string (eg</span>
<span class="sd">        &#39;&lt;ctrl&gt;+x &lt;ctrl&gt;+f&#39;), or a list of tuples containing the</span>
<span class="sd">        constants from the ``QtCore.Qt`` name space</span>
<span class="sd">        (eg. [(ControlModifier, Key_X), (ControlModifier, Key_F)]), or</span>
<span class="sd">        as a ``QtmacsKeysequence`` object.</span>

<span class="sd">        The ``applet`` parameter can either be an instance of</span>
<span class="sd">        ``QtmacsApplet`` or a string denoting an applet ID. In the</span>
<span class="sd">        latter case the ``qteGetAppletHandle`` method is used to fetch</span>
<span class="sd">        the respective applet instance.</span>

<span class="sd">        If ``applet`` does not refer to an existing applet then</span>
<span class="sd">        nothing happens.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``applet`` (**QtmacsApplet**, **str**): only widgets in this</span>
<span class="sd">          applet are affected.</span>
<span class="sd">        * ``keysequence`` (**str**, **list** of **tuples**,</span>
<span class="sd">          **QtmacsKeysequence**): the key sequence to remove.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        * **QtmacsKeysequenceError** if the provided ``keysequence``</span>
<span class="sd">          could not be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If ``applet`` was specified by its ID (ie. a string) then</span>
        <span class="c"># fetch the associated ``QtmacsApplet`` instance. If</span>
        <span class="c"># ``applet`` is already an instance of ``QtmacsApplet`` then</span>
        <span class="c"># use it directly.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">applet</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">appletObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">applet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">appletObj</span> <span class="o">=</span> <span class="n">applet</span>

        <span class="c"># Return immediately if the appletObj is invalid.</span>
        <span class="k">if</span> <span class="n">appletObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># Convert the key sequence into a QtmacsKeysequence object, or</span>
        <span class="c"># raise a QtmacsKeysequenceError if the conversion is</span>
        <span class="c"># impossible.</span>
        <span class="n">keysequence</span> <span class="o">=</span> <span class="n">QtmacsKeysequence</span><span class="p">(</span><span class="n">keysequence</span><span class="p">)</span>

        <span class="c"># Remove the key sequence from the applet window itself.</span>
        <span class="n">appletObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyMap</span><span class="o">.</span><span class="n">qteRemoveKey</span><span class="p">(</span><span class="n">keysequence</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">wid</span> <span class="ow">in</span> <span class="n">appletObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteUnbindKeyFromWidgetObject</span><span class="p">(</span><span class="n">keysequence</span><span class="p">,</span> <span class="n">wid</span><span class="p">)</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteUnbindKeyFromWidgetObject"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteUnbindKeyFromWidgetObject">[docs]</a>    <span class="k">def</span> <span class="nf">qteUnbindKeyFromWidgetObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keysequence</span><span class="p">,</span>
                                     <span class="n">widgetObj</span><span class="p">:</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disassociate the macro triggered by ``keysequence`` from</span>
<span class="sd">        ``widgetObj``.</span>

<span class="sd">        The ``keysequence`` can be specified either as a string (eg</span>
<span class="sd">        &#39;&lt;ctrl&gt;+x &lt;ctrl&gt;+f&#39;), or a list of tuples containing the</span>
<span class="sd">        constants from the ``QtCore.Qt`` name space</span>
<span class="sd">        (eg. [(ControlModifier, Key_X), (ControlModifier, Key_F)]), or</span>
<span class="sd">        as a ``QtmacsKeysequence`` object.</span>

<span class="sd">        This method does not affect the key bindings of other applets.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``keysequence`` (**str**, **list** of **tuples**,</span>
<span class="sd">          **QtmacsKeysequence**):</span>
<span class="sd">          key sequence to activate ``macroName`` for specified</span>
<span class="sd">          ``widgetSignature``.</span>
<span class="sd">        * ``widgetObj`` (**QWidget**): determines which widgets</span>
<span class="sd">          signature to use.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        * **QtmacsKeysequenceError** if the provided ``keysequence``</span>
<span class="sd">          could not be parsed.</span>
<span class="sd">        * **QtmacsOtherError** if ``widgetObj`` was not added with</span>
<span class="sd">          ``qteAddWidget``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Convert the key sequence into a QtmacsKeysequence object, or</span>
        <span class="c"># raise an QtmacsKeysequenceError if the conversion is</span>
        <span class="c"># impossible.</span>
        <span class="n">keysequence</span> <span class="o">=</span> <span class="n">QtmacsKeysequence</span><span class="p">(</span><span class="n">keysequence</span><span class="p">)</span>

        <span class="c"># Check type of input arguments.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">,</span> <span class="s">&#39;_qteAdmin&#39;</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&lt;widgetObj&gt; was probably not added with &lt;qteAddWidget&gt;&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; method because it lacks the &lt;_qteAdmin&gt; attribute.&#39;</span>
            <span class="k">raise</span> <span class="n">QtmacsOtherError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c"># Remove the key sequence from the local key maps.</span>
        <span class="n">widgetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyMap</span><span class="o">.</span><span class="n">qteRemoveKey</span><span class="p">(</span><span class="n">keysequence</span><span class="p">)</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteUnbindAllFromApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteUnbindAllFromApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteUnbindAllFromApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">applet</span><span class="p">:</span> <span class="p">(</span><span class="n">QtmacsApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restore the global key-map for all widgets inside ``applet``.</span>

<span class="sd">        This method effectively resets the key map of all widgets to</span>
<span class="sd">        the state they would be in if the widgets were newly</span>
<span class="sd">        instantiated right now.</span>

<span class="sd">        The ``applet`` parameter can either be an instance of</span>
<span class="sd">        ``QtmacsApplet`` or a string denoting an applet ID. In the</span>
<span class="sd">        latter case the ``qteGetAppletHandle`` method is used to fetch</span>
<span class="sd">        the respective applet instance.</span>

<span class="sd">        If ``applet`` does not refer to an existing applet then</span>
<span class="sd">        nothing happens.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``applet`` (**QtmacsApplet**, **str**): only widgets in this</span>
<span class="sd">          applet are affected.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If ``applet`` was specified by its ID (ie. a string) then</span>
        <span class="c"># fetch the associated ``QtmacsApplet`` instance. If</span>
        <span class="c"># ``applet`` is already an instance of ``QtmacsApplet`` then</span>
        <span class="c"># use it directly.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">applet</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">appletObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">applet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">appletObj</span> <span class="o">=</span> <span class="n">applet</span>

        <span class="c"># Return immediately if the appletObj is invalid.</span>
        <span class="k">if</span> <span class="n">appletObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># Remove the key sequence from the applet window itself.</span>
        <span class="n">appletObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteCopyGlobalKeyMap</span><span class="p">()</span>

        <span class="c"># Restore the global key-map for every widget.</span>
        <span class="k">for</span> <span class="n">wid</span> <span class="ow">in</span> <span class="n">appletObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">widgetList</span><span class="p">:</span>
            <span class="n">wid</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteCopyGlobalKeyMap</span><span class="p">()</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteUnbindAllFromWidgetObject"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteUnbindAllFromWidgetObject">[docs]</a>    <span class="k">def</span> <span class="nf">qteUnbindAllFromWidgetObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widgetObj</span><span class="p">:</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QWidget</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the local key-map of ``widgetObj`` to the current global</span>
<span class="sd">        key-map.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``widgetObj`` (**QWidget**): determines which widgets</span>
<span class="sd">          signature to use.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        * **QtmacsOtherError** if ``widgetObj`` was not added with</span>
<span class="sd">          ``qteAddWidget``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check type of input arguments.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">widgetObj</span><span class="p">,</span> <span class="s">&#39;_qteAdmin&#39;</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&lt;widgetObj&gt; was probably not added with &lt;qteAddWidget&gt;&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; method because it lacks the &lt;_qteAdmin&gt; attribute.&#39;</span>
            <span class="k">raise</span> <span class="n">QtmacsOtherError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c"># Install the global key-map for this widget.</span>
        <span class="n">widgetObj</span><span class="o">.</span><span class="n">_qteAdmin</span><span class="o">.</span><span class="n">keyMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteCopyGlobalKeyMap</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteCopyGlobalKeyMap"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteCopyGlobalKeyMap">[docs]</a>    <span class="k">def</span> <span class="nf">qteCopyGlobalKeyMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the global key map, not a reference.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsKeymap**: a copy of the global key map object.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QtmacsKeymap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteGlobalKeyMap</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_qteGlobalKeyMapByReference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a reference of the global key map, not a copy.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsKeymap**: a copy of the global key map object.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteGlobalKeyMap</span>

    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteRegisterApplet"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteRegisterApplet">[docs]</a>    <span class="k">def</span> <span class="nf">qteRegisterApplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">replaceApplet</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register ``cls`` as an applet.</span>

<span class="sd">        The name of the applet is the class name of ``cls``</span>
<span class="sd">        itself. For instance, if the applet was defined and registered</span>
<span class="sd">        as</span>

<span class="sd">            class NewApplet17(QtmacsApplet):</span>
<span class="sd">                ...</span>

<span class="sd">            app_name = qteRegisterApplet(NewApplet17)</span>

<span class="sd">        then the applet will be known as *NewApplet17*, which is also</span>
<span class="sd">        returned in ``app_name``.</span>

<span class="sd">        If an applet with this name already exists then</span>
<span class="sd">        ``replaceApplet`` decides whether the registration will</span>
<span class="sd">        overwrite the existing definition or ignore the registration</span>
<span class="sd">        request altogether. In the first case, none of the already</span>
<span class="sd">        instantiated applets will be affected, only newly created ones</span>
<span class="sd">        will use the new definition.</span>

<span class="sd">        .. note:: this method expects a *class*, not an instance.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``cls`` (**class QtmacsApplet**): this must really be a class,</span>
<span class="sd">          not an instance.</span>
<span class="sd">        * ``replaceApplet`` (**bool**): if applet with same name exists,</span>
<span class="sd">          then replace it.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **str**: name under which the applet was registered with Qtmacs.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check type of input arguments.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">QtmacsApplet</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;cls&#39;</span><span class="p">,</span> <span class="s">&#39;class QtmacsApplet&#39;</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">raise</span> <span class="n">QtmacsArgumentError</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c"># Extract the class name as string, because this is the name</span>
        <span class="c"># under which the applet will be known.</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span>

        <span class="c"># Issue a warning if an applet with this name already exists.</span>
        <span class="k">if</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryApplets</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;The original applet &lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">replaceApplet</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; was redefined.&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39; was not redefined.&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">class_name</span>

        <span class="c"># Execute the classmethod __qteRegisterAppletInit__ to</span>
        <span class="c"># allow the applet to make global initialisations that do</span>
        <span class="c"># not depend on a particular instance, eg. the supported</span>
        <span class="c"># file types.</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__qteRegisterAppletInit__</span><span class="p">()</span>

        <span class="c"># Add the class (not instance!) to the applet registry.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryApplets</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Applet &lt;b&gt;{}&lt;/b&gt; now registered.&#39;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">class_name</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteGetAllAppletIDs"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteGetAllAppletIDs">[docs]</a>    <span class="k">def</span> <span class="nf">qteGetAllAppletIDs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of all applet IDs currently active in Qtmacs.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **tuple**: IDs of all open applets.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteGetAllAppletNames"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteGetAllAppletNames">[docs]</a>    <span class="k">def</span> <span class="nf">qteGetAllAppletNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of all registered applet names.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **tuple**: name of applets.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteRegistryApplets</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteGetAppletHandle"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteGetAppletHandle">[docs]</a>    <span class="k">def</span> <span class="nf">qteGetAppletHandle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appletID</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a handle to ``appletID``.</span>

<span class="sd">        If no applet with ID ``appletID`` exists then **None** is</span>
<span class="sd">        returned.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``appletID`` (**str**): ID of applet.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **QtmacsApplet**: handle to applet with ID ``appletID``.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Compile list of applet Ids.</span>
        <span class="n">id_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">qteAppletID</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">]</span>

        <span class="c"># If one of the applets has ``appletID`` then return a</span>
        <span class="c"># reference to it.</span>
        <span class="k">if</span> <span class="n">appletID</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">id_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">appletID</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteMakeAppletActive"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteMakeAppletActive">[docs]</a>    <span class="k">def</span> <span class="nf">qteMakeAppletActive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">applet</span><span class="p">:</span> <span class="p">(</span><span class="n">QtmacsApplet</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make ``applet`` visible and give it the focus.</span>

<span class="sd">        If ``applet`` is not yet visible it will replace the</span>
<span class="sd">        currently active applet, otherwise only the focus will shift.</span>

<span class="sd">        The ``applet`` parameter can either be an instance of</span>
<span class="sd">        ``QtmacsApplet`` or a string denoting an applet ID. In the</span>
<span class="sd">        latter case the ``qteGetAppletHandle`` method is used to fetch</span>
<span class="sd">        the respective applet instance.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``applet`` (**QtmacsApplet**, **str**): the applet to activate.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **bool**: whether or not an applet was activated.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If ``applet`` was specified by its ID (ie. a string) then</span>
        <span class="c"># fetch the associated ``QtmacsApplet`` instance. If</span>
        <span class="c"># ``applet`` is already an instance of ``QtmacsApplet`` then</span>
        <span class="c"># use it directly.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">applet</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">appletObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAppletHandle</span><span class="p">(</span><span class="n">applet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">appletObj</span> <span class="o">=</span> <span class="n">applet</span>

        <span class="c"># Sanity check: return if the applet does not exist.</span>
        <span class="k">if</span> <span class="n">appletObj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteAppletList</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># If ``appletObj`` is a mini applet then double check that it</span>
        <span class="c"># is actually installed and visible. If it is a conventional</span>
        <span class="c"># applet then insert it into the layout.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteIsMiniApplet</span><span class="p">(</span><span class="n">appletObj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">appletObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteLogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Wrong mini applet. Not activated.&#39;</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="n">appletObj</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qteMiniApplet</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">appletObj</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">():</span>
                <span class="n">appletObj</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">appletObj</span><span class="o">.</span><span class="n">qteIsVisible</span><span class="p">():</span>
                <span class="c"># Add the applet to the layout by replacing the</span>
                <span class="c"># currently active applet.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qteReplaceAppletInLayout</span><span class="p">(</span><span class="n">appletObj</span><span class="p">)</span>

        <span class="c"># Update the qteActiveApplet pointer. Note that the actual</span>
        <span class="c"># focusing is done exclusively in the focus manager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteActiveApplet</span> <span class="o">=</span> <span class="n">appletObj</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="QtmacsMain.qteCloseQtmacs"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteCloseQtmacs">[docs]</a>    <span class="k">def</span> <span class="nf">qteCloseQtmacs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close Qtmacs.</span>

<span class="sd">        First kill all applets, then shut down Qtmacs.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **None**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Announce the shutdown.</span>
        <span class="n">msgObj</span> <span class="o">=</span> <span class="n">QtmacsMessage</span><span class="p">()</span>
        <span class="n">msgObj</span><span class="o">.</span><span class="n">setSignalName</span><span class="p">(</span><span class="s">&#39;qtesigCloseQtmacs&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qtesigCloseQtmacs</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">msgObj</span><span class="p">)</span>

        <span class="c"># Kill all applets and update the GUI.</span>
        <span class="k">for</span> <span class="n">appName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qteGetAllAppletIDs</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qteKillApplet</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteFocusManager</span><span class="p">()</span>

        <span class="c"># Kill all windows and update the GUI.</span>
        <span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qteWindowList</span><span class="p">:</span>
            <span class="n">window</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteFocusManager</span><span class="p">()</span>

        <span class="c"># Schedule QtmacsMain for deletion.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleteLater</span><span class="p">()</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteStatus"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteStatus">[docs]</a>    <span class="k">def</span> <span class="nf">qteStatus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dispatch ``msg`` via the ``qteStatus`` hook.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``msg`` (**str**): the message to distribute.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qteRunHook</span><span class="p">(</span><span class="s">&#39;qteStatus&#39;</span><span class="p">,</span> <span class="n">QtmacsMessage</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteDefVar"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteDefVar">[docs]</a>    <span class="k">def</span> <span class="nf">qteDefVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define and document ``varName`` in an arbitrary name space.</span>

<span class="sd">        If ``module`` is **None** then ``qte_global`` will be used.</span>

<span class="sd">        .. warning: If the ``varName`` was already defined in</span>
<span class="sd">           ``module`` then its value and documentation are overwritten</span>
<span class="sd">           without warning.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``varName`` (**str**): variable name.</span>
<span class="sd">        * ``value`` (**object**): arbitrary data to store.</span>
<span class="sd">        * ``module`` (**Python module**): the module in which the</span>
<span class="sd">          variable should be defined.</span>
<span class="sd">        * ``doc`` (**str**): documentation string for variable.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        **bool**: **True** if ``varName`` could be defined in</span>
<span class="sd">          ``module``.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Use the global name space per default.</span>
        <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">qte_global</span>

        <span class="c"># Create the documentation dictionary if it does not exist</span>
        <span class="c"># already.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;_qte__variable__docstring__dictionary__&#39;</span><span class="p">):</span>
            <span class="n">module</span><span class="o">.</span><span class="n">_qte__variable__docstring__dictionary__</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Set the variable value and documentation string.</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">varName</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">module</span><span class="o">.</span><span class="n">_qte__variable__docstring__dictionary__</span><span class="p">[</span><span class="n">varName</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@type_check</span>
<div class="viewcode-block" id="QtmacsMain.qteGetVariableDoc"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteGetVariableDoc">[docs]</a>    <span class="k">def</span> <span class="nf">qteGetVariableDoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve documentation for ``varName`` defined in ``module``.</span>

<span class="sd">        If ``module`` is **None** then ``qte_global`` will be used.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``varName`` (**str**): variable name.</span>
<span class="sd">        * ``module`` (**Python module**): the module in which the</span>
<span class="sd">          variable should be defined.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        **str**: documentation string for ``varName``.</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Use the global name space per default.</span>
        <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">qte_global</span>

        <span class="c"># No documentation for the variable can exists if the doc</span>
        <span class="c"># string dictionary is undefined.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;_qte__variable__docstring__dictionary__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># If the variable is undefined then return **None**.</span>
        <span class="k">if</span> <span class="n">varName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">_qte__variable__docstring__dictionary__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Return the requested value.</span>
        <span class="k">return</span> <span class="n">module</span><span class="o">.</span><span class="n">_qte__variable__docstring__dictionary__</span><span class="p">[</span><span class="n">varName</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">qteEnableMacroProcessing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteEventFilter</span><span class="o">.</span><span class="n">qteEnableMacroProcessing</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">qteDisableMacroProcessing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qteEventFilter</span><span class="o">.</span><span class="n">qteDisableMacroProcessing</span><span class="p">()</span>

<div class="viewcode-block" id="QtmacsMain.qteEmulateKeypresses"><a class="viewcode-back" href="../../qtmacs_autodoc.html#qtmacs.qtmacsmain.QtmacsMain.qteEmulateKeypresses">[docs]</a>    <span class="k">def</span> <span class="nf">qteEmulateKeypresses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keysequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emulate the Qt key presses that define ``keysequence``.</span>

<span class="sd">        The method will put the keys into a queue and process them one</span>
<span class="sd">        by one once the event loop is idle, ie. the event loop</span>
<span class="sd">        executes all signals and macros associated with the emulated</span>
<span class="sd">        key press first before the next one is emulated.</span>

<span class="sd">        |Args|</span>

<span class="sd">        * ``keysequence`` (**QtmacsKeysequence**): the key sequence to</span>
<span class="sd">          emulate.</span>

<span class="sd">        |Returns|</span>

<span class="sd">        * **None**</span>

<span class="sd">        |Raises|</span>

<span class="sd">        * **QtmacsArgumentError** if at least one argument has an invalid type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Convert the key sequence into a QtmacsKeysequence object, or</span>
        <span class="c"># raise an QtmacsOtherError if the conversion is impossible.</span>
        <span class="n">keysequence</span> <span class="o">=</span> <span class="n">QtmacsKeysequence</span><span class="p">(</span><span class="n">keysequence</span><span class="p">)</span>
        <span class="n">key_list</span> <span class="o">=</span> <span class="n">keysequence</span><span class="o">.</span><span class="n">toQKeyEventList</span><span class="p">()</span>

        <span class="c"># Do nothing if the key list is empty.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Add the keys to the queue which the event timer will</span>
            <span class="c"># process.</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">key_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qteKeyEmulationQueue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="../../titlepage.html">
          <img class="logo" src="../../_static/Max.png" alt="Logo"/>
        </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">Qtmacs 0.1 documentation</a> &raquo;</li>

          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    </div>

    <div class="footer">
        &copy; Copyright 2012-2013, Oliver Nagy.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>